/*{
    "type": "action",
    "targets": ["omnifocus"],
    "author": "OmniFocus Automation",
    "identifier": "com.omnifocus.ai-task-clarifier",
    "version": "1.8.0",
    "description": "Analyzes tasks and projects using OpenAI GPT-5 to identify vague, non-actionable, or problematic items and provides improvement suggestions",
    "label": "AI Task Clarifier",
    "shortLabel": "AI Clarifier",
    "paletteLabel": "Analyze Tasks with AI",
    "image": "wand.and.stars"
}*/
(() => {
    const credentials = new Credentials();

    const action = new PlugIn.Action(async function(selection, sender) {
        try {
            console.log("=== AI Task Clarifier Debug Log ===");
            console.log("Starting plugin execution...");

            // Get OpenAI API key from credentials
            let apiKey = null;
            const storedCreds = credentials.read("openai");
            console.log("Credentials check:", storedCreds ? "Found stored credentials" : "No stored credentials");

            if (!storedCreds || !storedCreds.password) {
                console.log("No credentials found, prompting user (required for first run)...");
                const form = new Form();
                form.addField(new Form.Field.Password("apiKey", "OpenAI API Key", null));

                const formPrompt = await form.show("Enter your OpenAI API key (will be stored securely in Keychain)", "Continue");
                apiKey = formPrompt.values.apiKey;

                if (!apiKey) {
                    throw new Error("API key is required");
                }

                console.log("Storing new API key in Keychain...");
                credentials.write("openai", "api-key", apiKey);
                console.log("API key stored successfully");
            } else {
                const alert = new Alert("OpenAI Credentials Found", "Stored API key found. What would you like to do?");
                alert.addOption("Use Stored Key");
                alert.addOption("Clear & Re-enter Key");
                alert.addOption("Cancel");

                const choice = await alert.show();

                if (choice === 0) {
                    apiKey = storedCreds.password;
                    console.log("Using stored API key");
                } else if (choice === 1) {
                    console.log("Clearing stored credentials...");
                    credentials.remove("openai");

                    const form = new Form();
                    form.addField(new Form.Field.Password("apiKey", "OpenAI API Key", null));

                    const formPrompt = await form.show("Enter your OpenAI API key (will be stored securely in Keychain)", "Continue");
                    apiKey = formPrompt.values.apiKey;

                    if (!apiKey) {
                        throw new Error("API key is required");
                    }

                    console.log("Storing new API key in Keychain...");
                    credentials.write("openai", "api-key", apiKey);
                    console.log("API key stored successfully");
                } else {
                    console.log("User cancelled");
                    return;
                }
            }

            // Get items to analyze (tasks and/or projects)
            let analyzeItems = []; // [{item, type: 'task'|'project'}, ...]
            console.log("Selection check - tasks selected:", selection.tasks.length, "projects selected:", selection.projects.length);

            // Collect items from the selection
            if (selection.tasks.length > 0 || selection.projects.length > 0) {
                const seen = new Set();
                for (const task of selection.tasks) {
                    if (!seen.has(task.id.primaryKey) && !task.completed) {
                        seen.add(task.id.primaryKey);
                        analyzeItems.push({item: task, type: 'task'});
                    }
                }
                for (const project of selection.projects) {
                    analyzeItems.push({item: project, type: 'project'});
                }
                console.log("Items from selection:", analyzeItems.length, "(tasks:", analyzeItems.filter(e => e.type === 'task').length, "projects:", analyzeItems.filter(e => e.type === 'project').length + ")");
            }

            // If selection yielded no items, fall back to scope selection
            if (analyzeItems.length === 0) {
                let scopeTasks = [];
                const form = new Form();
                const scopeField = new Form.Field.Option(
                    "scope",
                    "Analyze which tasks?",
                    ["Selected tasks/projects", "All incomplete tasks", "Tasks older than 30 days"],
                    null,
                    "All incomplete tasks"
                );
                form.addField(scopeField);

                const formPrompt = await form.show("Task Analysis Scope", "Continue");
                const scope = formPrompt.values.scope;
                console.log("User selected scope:", scope);

                if (scope === "Selected tasks/projects") {
                    throw new Error("No tasks selected. Please select tasks/projects or choose a different scope.");
                } else if (scope === "All incomplete tasks") {
                    scopeTasks = flattenedTasks.filter(task => !task.completed && !task.dropped);
                    console.log("Analyzing all incomplete tasks:", scopeTasks.length);
                } else {
                    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                    scopeTasks = flattenedTasks.filter(task => {
                        return !task.completed && !task.dropped && task.added && task.added < thirtyDaysAgo;
                    });
                    console.log("Analyzing tasks older than 30 days:", scopeTasks.length);
                }
                analyzeItems = scopeTasks.map(task => ({item: task, type: 'task'}));
            }

            if (analyzeItems.length === 0) {
                console.log("No items found matching criteria");
                new Alert("No Tasks Found", "No tasks match the selected criteria.").show();
                return;
            }

            console.log("Total items to analyze:", analyzeItems.length);

            // Limit to 20 items to avoid timeout issues
            if (analyzeItems.length > 20) {
                console.log("Too many items, limiting to 20");
                const alert = new Alert("Too Many Tasks", `Found ${analyzeItems.length} items. Will analyze the first 20 only to avoid timeouts.`);
                alert.addOption("Continue");
                alert.addOption("Cancel");
                const choice = await alert.show();
                if (choice === 1) {
                    console.log("User cancelled due to item limit");
                    return;
                }
                analyzeItems = analyzeItems.slice(0, 20);
                console.log("Limited to 20 items");
            }

            // Prepare data for AI analysis
            console.log("Preparing data for AI analysis...");
            const taskData = analyzeItems.map((entry, index) => {
                if (entry.type === 'project') {
                    return {
                        index: index,
                        name: entry.item.name,
                        note: entry.item.note ? entry.item.note.substring(0, 200) : "",
                        age_days: 0,
                        has_due_date: !!entry.item.dueDate,
                        has_defer_date: !!entry.item.deferDate,
                        flagged: false,
                        tags: "",
                        type: "project"
                    };
                }
                const task = entry.item;
                const age = task.added ? Math.floor((Date.now() - task.added.getTime()) / (1000 * 60 * 60 * 24)) : 0;
                return {
                    index: index,
                    name: task.name,
                    note: task.note ? task.note.substring(0, 200) : "",
                    age_days: age,
                    has_due_date: !!task.dueDate,
                    has_defer_date: !!task.deferDate,
                    flagged: task.flagged,
                    tags: task.tags.map(t => t.name).join(", ")
                };
            });
            console.log("Task data prepared, sample:", JSON.stringify(taskData[0], null, 2));

            // Call OpenAI API
            console.log("Preparing OpenAI API request...");
            const request = new URL.FetchRequest();
            request.url = URL.fromString("https://api.openai.com/v1/chat/completions");
            request.method = "POST";
            request.headers = {
                "Authorization": `Bearer ${apiKey}`,
                "Content-Type": "application/json"
            };

            const systemPrompt = `You are a productivity expert analyzing OmniFocus tasks and projects. Identify items that are:
1. Vague or non-actionable (e.g., "Think about project" instead of "Draft project proposal outline")
2. Too broad (should be broken into subtasks)
3. Missing critical context
4. Stale (old tasks with no progress)
5. Ambiguous or unclear

Items with type "project" are project containers â€” analyze their names and notes for clarity, specificity, and whether they represent a clear outcome.

For each problematic item, provide:
- Issue type (vague/broad/stale/ambiguous/missing-context)
- Severity (low/medium/high)
- Specific, actionable suggestion for improvement
- Recommended action (clarify/break-down/defer/delete/add-context)

IMPORTANT: Return a JSON object with an "analysis" array. Each item must have: index, issue, severity, suggestion, action.
Example format: {"analysis": [{"index": 0, "issue": "vague", "severity": "high", "suggestion": "...", "action": "clarify"}]}`;

            const requestBody = {
                model: "gpt-5-2025-08-07",
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: `Analyze these tasks:\n${JSON.stringify(taskData, null, 2)}` }
                ],
                response_format: { type: "json_object" }
            };

            request.bodyString = JSON.stringify(requestBody);

            console.log("=== OpenAI API Request ===");
            console.log("URL:", request.url.string);
            console.log("Method:", request.method);
            console.log("API Key (first 20 chars):", apiKey.substring(0, 20) + "...");
            console.log("Request Body:", JSON.stringify(requestBody, null, 2));

            // Show progress
            const progress = new Alert("Analyzing Tasks", "Sending tasks to OpenAI for analysis...\n\nThis may take 15-30 seconds.");
            progress.show(() => {});

            console.log("Sending request to OpenAI...");

            let response;
            try {
                response = await request.fetch();
            } catch (fetchError) {
                console.error("Fetch error:", fetchError);
                throw new Error(`Network request failed: ${fetchError.message || 'Request timed out'}. Try analyzing fewer tasks (5-10) or check your internet connection.`);
            }

            console.log("=== OpenAI API Response ===");
            console.log("Status Code:", response.statusCode);
            console.log("Response Body:", response.bodyString);

            if (response.statusCode !== 200) {
                console.error("API Error - Status:", response.statusCode);
                console.error("API Error - Body:", response.bodyString);
                throw new Error(`API Error: ${response.statusCode} - ${response.bodyString}`);
            }

            const data = JSON.parse(response.bodyString);
            console.log("Parsed response data:", JSON.stringify(data, null, 2));

            const aiResponse = JSON.parse(data.choices[0].message.content);
            console.log("Parsed AI response:", JSON.stringify(aiResponse, null, 2));

            // Process results
            const issues = aiResponse.results || aiResponse.issues || aiResponse.analysis || [];
            console.log("Issues found:", issues.length);

            if (issues.length === 0) {
                console.log("No issues found, analysis complete");
                new Alert("Analysis Complete", "No significant issues found! Your tasks look good.").show();
                return;
            }

            // Create or get "AI: Needs Improvement" tag
            console.log("Creating/finding 'AI: Needs Improvement' tag...");
            let improvementTag = tags.byName("AI: Needs Improvement");
            if (!improvementTag) {
                improvementTag = new Tag("AI: Needs Improvement", tags.ending);
                console.log("Created new 'AI: Needs Improvement' tag");
            } else {
                console.log("Found existing 'AI: Needs Improvement' tag");
            }

            // Apply findings to tasks and projects
            console.log("Applying findings...");
            let updatedCount = 0;
            let flaggedCount = 0;

            issues.forEach((issue, idx) => {
                console.log(`Processing issue ${idx + 1}/${issues.length}:`, JSON.stringify(issue));
                const entry = analyzeItems[issue.index];
                if (!entry) {
                    console.warn(`Item not found at index ${issue.index}`);
                    return;
                }

                console.log(`Updating ${entry.type}: "${entry.item.name}"`);

                const analysisNote = `\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¤– AI IMPROVEMENT SUGGESTION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“… Date: ${new Date().toLocaleDateString()}

âš ï¸  Issue Type: ${issue.issue.toUpperCase()}
ğŸ“Š Severity: ${issue.severity.toUpperCase()}

ğŸ’¡ SUGGESTION:
${issue.suggestion}

ğŸ¯ Recommended Action: ${issue.action}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

                if (entry.type === 'project') {
                    const project = entry.item;
                    project.note = (project.note || "") + analysisNote;
                    if (project.task) {
                        project.task.addTag(improvementTag);
                        if (issue.severity === "high") {
                            project.task.flagged = true;
                            flaggedCount++;
                            console.log(`Flagged project due to high severity`);
                        }
                    }
                } else {
                    const task = entry.item;
                    task.note = (task.note || "") + analysisNote;
                    task.addTag(improvementTag);
                    console.log(`Added 'AI: Needs Improvement' tag`);
                    if (issue.severity === "high") {
                        task.flagged = true;
                        flaggedCount++;
                        console.log(`Flagged task due to high severity`);
                    }
                }

                updatedCount++;
            });
            console.log(`Updated ${updatedCount} items, flagged ${flaggedCount} high-severity`);

            // Show summary
            const summary = `Analysis Complete!\n\n` +
                `Items analyzed: ${analyzeItems.length}\n` +
                `Issues found: ${issues.length}\n` +
                `Items updated: ${updatedCount}\n` +
                `High-severity flagged: ${flaggedCount}\n\n` +
                `âœ… Tagged with "AI: Needs Improvement"\n` +
                `ğŸ“ Suggestions added to task notes\n` +
                `ğŸš© High-severity tasks flagged\n\n` +
                `Filter by tag to review improvements!`;

            console.log("=== Analysis Summary ===");
            console.log(summary);
            console.log("=== End Debug Log ===");

            new Alert("AI Task Clarifier", summary).show();

        } catch (error) {
            console.error("=== ERROR ===");
            console.error("Error message:", error.message);
            console.error("Error stack:", error.stack);
            console.error("=== End Debug Log ===");
            new Alert("Error", error.message).show();
        }
    });

    action.validate = function(selection, sender) {
        return true; // Always available
    };

    return action;
})();
