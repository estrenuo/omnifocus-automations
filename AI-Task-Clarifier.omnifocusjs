/*{
    "type": "action",
    "targets": ["omnifocus"],
    "author": "OmniFocus Automation",
    "identifier": "com.omnifocus.ai-task-clarifier",
    "version": "2.0.0",
    "description": "Analyzes tasks using Claude AI to identify vague, non-actionable, or problematic tasks and provides improvement suggestions",
    "label": "AI Task Clarifier",
    "shortLabel": "AI Clarifier",
    "paletteLabel": "Analyze Tasks with AI",
    "image": "wand.and.stars"
}*/
(() => {
    // Credentials for storing Anthropic API key
    const credentials = new Credentials();

    const action = new PlugIn.Action(async function(selection, sender) {
        try {
            console.log("=== AI Task Clarifier Debug Log ===");
            console.log("Starting plugin execution...");

            // Headless mode: skip all dialogs, use stored credentials and defaults
            const prefs = new Preferences("com.omnifocus.ai-task-clarifier");
            const headless = prefs.readBoolean("headlessMode");
            const defaultScope = prefs.readString("defaultScope") || "all"; // "all" | "selected" | "stale"
            console.log("Headless mode:", headless, "Default scope:", defaultScope);

            // Get system language from macOS settings (needed for all UI)
            const localeIdentifier = Calendar.current.locale ? Calendar.current.locale.identifier : "en_US";
            const localeFormatted = localeIdentifier.replace("_", "-"); // Convert nl_NL to nl-NL for BCP 47
            const languageCode = localeIdentifier.split("_")[0];
            const languageNames = {
                "en": "English", "nl": "Dutch", "de": "German", "fr": "French",
                "es": "Spanish", "it": "Italian", "pt": "Portuguese", "ja": "Japanese",
                "zh": "Chinese", "ko": "Korean", "ru": "Russian", "ar": "Arabic",
                "sv": "Swedish", "da": "Danish", "no": "Norwegian", "fi": "Finnish",
                "pl": "Polish", "cs": "Czech", "hu": "Hungarian", "tr": "Turkish",
                "he": "Hebrew", "th": "Thai", "vi": "Vietnamese", "id": "Indonesian"
            };
            const languageName = languageNames[languageCode] || languageCode;
            console.log("System locale:", localeIdentifier, "Language:", languageName);

            // Localized UI strings
            const ui = {
                "en": {
                    apiKeyLabel: "Anthropic API Key", apiKeyPrompt: "Enter your Anthropic API key (will be stored securely in Keychain)", continue: "Continue", cancel: "Cancel",
                    credentialsFound: "Anthropic Credentials Found", credentialsFoundMsg: "Stored API key found. What would you like to do?",
                    useStoredKey: "Use Stored Key", clearReenter: "Clear & Re-enter Key", apiKeyRequired: "API key is required",
                    analyzeWhich: "Analyze which tasks?", selectedOnly: "Selected tasks only", allIncomplete: "All incomplete tasks", olderThan30: "Tasks older than 30 days",
                    taskScope: "Task Analysis Scope", noTasksSelected: "No tasks selected. Please select tasks or choose a different scope.",
                    noTasksFound: "No Tasks Found", noTasksFoundMsg: "No tasks match the selected criteria.",
                    tooManyTasks: "Too Many Tasks", tooManyTasksMsg: "tasks. Will analyze the first 20 tasks only to avoid timeouts.",
                    analyzing: "Analyzing Tasks", analyzingMsg: "Sending tasks to AI for analysis...\n\nThis may take 15-30 seconds.",
                    analysisComplete: "Analysis Complete", noIssuesFound: "No significant issues found! Your tasks look good.",
                    tasksAnalyzed: "Tasks analyzed", issuesFound: "Issues found", tasksUpdated: "Tasks updated", highSeverityFlagged: "High-severity flagged",
                    taggedWith: "Tagged with", suggestionsAdded: "Suggestions added to task notes", highSeverityTasksFlagged: "High-severity tasks flagged",
                    filterByTag: "Filter by tag to review improvements!", error: "Error",
                    // Note labels
                    title: "AI IMPROVEMENT SUGGESTION", date: "Date", issueType: "Issue Type", severity: "Severity", suggestion: "SUGGESTION", recommendedAction: "Recommended Action"
                },
                "nl": {
                    apiKeyLabel: "Anthropic API-sleutel", apiKeyPrompt: "Voer je Anthropic API-sleutel in (wordt veilig opgeslagen in Sleutelhanger)", continue: "Doorgaan", cancel: "Annuleren",
                    credentialsFound: "Anthropic inloggegevens gevonden", credentialsFoundMsg: "Opgeslagen API-sleutel gevonden. Wat wil je doen?",
                    useStoredKey: "Gebruik opgeslagen sleutel", clearReenter: "Wissen en opnieuw invoeren", apiKeyRequired: "API-sleutel is vereist",
                    analyzeWhich: "Welke taken analyseren?", selectedOnly: "Alleen geselecteerde taken", allIncomplete: "Alle onvoltooide taken", olderThan30: "Taken ouder dan 30 dagen",
                    taskScope: "Analysebereik", noTasksSelected: "Geen taken geselecteerd. Selecteer taken of kies een ander bereik.",
                    noTasksFound: "Geen taken gevonden", noTasksFoundMsg: "Geen taken voldoen aan de criteria.",
                    tooManyTasks: "Te veel taken", tooManyTasksMsg: "taken. Alleen de eerste 20 taken worden geanalyseerd.",
                    analyzing: "Taken analyseren", analyzingMsg: "Taken worden naar AI gestuurd voor analyse...\n\nDit kan 15-30 seconden duren.",
                    analysisComplete: "Analyse voltooid", noIssuesFound: "Geen problemen gevonden! Je taken zien er goed uit.",
                    tasksAnalyzed: "Taken geanalyseerd", issuesFound: "Problemen gevonden", tasksUpdated: "Taken bijgewerkt", highSeverityFlagged: "Hoge prioriteit gemarkeerd",
                    taggedWith: "Getagd met", suggestionsAdded: "Suggesties toegevoegd aan taaknota's", highSeverityTasksFlagged: "Taken met hoge prioriteit gemarkeerd",
                    filterByTag: "Filter op tag om verbeteringen te bekijken!", error: "Fout",
                    title: "AI VERBETERVOORSTEL", date: "Datum", issueType: "Probleemtype", severity: "Ernst", suggestion: "SUGGESTIE", recommendedAction: "Aanbevolen actie"
                },
                "de": {
                    apiKeyLabel: "Anthropic API-SchlÃ¼ssel", apiKeyPrompt: "Geben Sie Ihren Anthropic API-SchlÃ¼ssel ein (wird sicher im SchlÃ¼sselbund gespeichert)", continue: "Weiter", cancel: "Abbrechen",
                    credentialsFound: "Anthropic Anmeldedaten gefunden", credentialsFoundMsg: "Gespeicherter API-SchlÃ¼ssel gefunden. Was mÃ¶chten Sie tun?",
                    useStoredKey: "Gespeicherten SchlÃ¼ssel verwenden", clearReenter: "LÃ¶schen und neu eingeben", apiKeyRequired: "API-SchlÃ¼ssel erforderlich",
                    analyzeWhich: "Welche Aufgaben analysieren?", selectedOnly: "Nur ausgewÃ¤hlte Aufgaben", allIncomplete: "Alle unerledigten Aufgaben", olderThan30: "Aufgaben Ã¤lter als 30 Tage",
                    taskScope: "Analysebereich", noTasksSelected: "Keine Aufgaben ausgewÃ¤hlt. Bitte wÃ¤hlen Sie Aufgaben oder einen anderen Bereich.",
                    noTasksFound: "Keine Aufgaben gefunden", noTasksFoundMsg: "Keine Aufgaben entsprechen den Kriterien.",
                    tooManyTasks: "Zu viele Aufgaben", tooManyTasksMsg: "Aufgaben. Nur die ersten 20 werden analysiert.",
                    analyzing: "Aufgaben analysieren", analyzingMsg: "Aufgaben werden zur Analyse an KI gesendet...\n\nDies kann 15-30 Sekunden dauern.",
                    analysisComplete: "Analyse abgeschlossen", noIssuesFound: "Keine Probleme gefunden! Ihre Aufgaben sehen gut aus.",
                    tasksAnalyzed: "Aufgaben analysiert", issuesFound: "Probleme gefunden", tasksUpdated: "Aufgaben aktualisiert", highSeverityFlagged: "Hohe PrioritÃ¤t markiert",
                    taggedWith: "Markiert mit", suggestionsAdded: "VorschlÃ¤ge zu Aufgabennotizen hinzugefÃ¼gt", highSeverityTasksFlagged: "Aufgaben mit hoher PrioritÃ¤t markiert",
                    filterByTag: "Nach Tag filtern um Verbesserungen zu sehen!", error: "Fehler",
                    title: "KI-VERBESSERUNGSVORSCHLAG", date: "Datum", issueType: "Problemtyp", severity: "Schweregrad", suggestion: "VORSCHLAG", recommendedAction: "Empfohlene Aktion"
                },
                "fr": {
                    apiKeyLabel: "ClÃ© API Anthropic", apiKeyPrompt: "Entrez votre clÃ© API Anthropic (sera stockÃ©e en sÃ©curitÃ© dans le trousseau)", continue: "Continuer", cancel: "Annuler",
                    credentialsFound: "Identifiants Anthropic trouvÃ©s", credentialsFoundMsg: "ClÃ© API enregistrÃ©e trouvÃ©e. Que voulez-vous faire?",
                    useStoredKey: "Utiliser la clÃ© enregistrÃ©e", clearReenter: "Effacer et ressaisir", apiKeyRequired: "ClÃ© API requise",
                    analyzeWhich: "Quelles tÃ¢ches analyser?", selectedOnly: "TÃ¢ches sÃ©lectionnÃ©es uniquement", allIncomplete: "Toutes les tÃ¢ches incomplÃ¨tes", olderThan30: "TÃ¢ches de plus de 30 jours",
                    taskScope: "PortÃ©e de l'analyse", noTasksSelected: "Aucune tÃ¢che sÃ©lectionnÃ©e. Veuillez sÃ©lectionner des tÃ¢ches ou choisir une autre portÃ©e.",
                    noTasksFound: "Aucune tÃ¢che trouvÃ©e", noTasksFoundMsg: "Aucune tÃ¢che ne correspond aux critÃ¨res.",
                    tooManyTasks: "Trop de tÃ¢ches", tooManyTasksMsg: "tÃ¢ches. Seules les 20 premiÃ¨res seront analysÃ©es.",
                    analyzing: "Analyse des tÃ¢ches", analyzingMsg: "Envoi des tÃ¢ches Ã  l'IA pour analyse...\n\nCela peut prendre 15-30 secondes.",
                    analysisComplete: "Analyse terminÃ©e", noIssuesFound: "Aucun problÃ¨me trouvÃ©! Vos tÃ¢ches sont bien dÃ©finies.",
                    tasksAnalyzed: "TÃ¢ches analysÃ©es", issuesFound: "ProblÃ¨mes trouvÃ©s", tasksUpdated: "TÃ¢ches mises Ã  jour", highSeverityFlagged: "Haute prioritÃ© signalÃ©e",
                    taggedWith: "Ã‰tiquetÃ© avec", suggestionsAdded: "Suggestions ajoutÃ©es aux notes", highSeverityTasksFlagged: "TÃ¢ches haute prioritÃ© signalÃ©es",
                    filterByTag: "Filtrez par tag pour voir les amÃ©liorations!", error: "Erreur",
                    title: "SUGGESTION D'AMÃ‰LIORATION IA", date: "Date", issueType: "Type de problÃ¨me", severity: "GravitÃ©", suggestion: "SUGGESTION", recommendedAction: "Action recommandÃ©e"
                },
                "es": {
                    apiKeyLabel: "Clave API Anthropic", apiKeyPrompt: "Ingresa tu clave API de Anthropic (se guardarÃ¡ de forma segura)", continue: "Continuar", cancel: "Cancelar",
                    credentialsFound: "Credenciales Anthropic encontradas", credentialsFoundMsg: "Clave API guardada encontrada. Â¿QuÃ© deseas hacer?",
                    useStoredKey: "Usar clave guardada", clearReenter: "Borrar y reingresar", apiKeyRequired: "Se requiere clave API",
                    analyzeWhich: "Â¿QuÃ© tareas analizar?", selectedOnly: "Solo tareas seleccionadas", allIncomplete: "Todas las tareas incompletas", olderThan30: "Tareas de mÃ¡s de 30 dÃ­as",
                    taskScope: "Alcance del anÃ¡lisis", noTasksSelected: "No hay tareas seleccionadas. Selecciona tareas o elige otro alcance.",
                    noTasksFound: "No se encontraron tareas", noTasksFoundMsg: "Ninguna tarea coincide con los criterios.",
                    tooManyTasks: "Demasiadas tareas", tooManyTasksMsg: "tareas. Solo se analizarÃ¡n las primeras 20.",
                    analyzing: "Analizando tareas", analyzingMsg: "Enviando tareas a la IA para anÃ¡lisis...\n\nEsto puede tomar 15-30 segundos.",
                    analysisComplete: "AnÃ¡lisis completado", noIssuesFound: "Â¡No se encontraron problemas! Tus tareas se ven bien.",
                    tasksAnalyzed: "Tareas analizadas", issuesFound: "Problemas encontrados", tasksUpdated: "Tareas actualizadas", highSeverityFlagged: "Alta prioridad marcada",
                    taggedWith: "Etiquetado con", suggestionsAdded: "Sugerencias aÃ±adidas a las notas", highSeverityTasksFlagged: "Tareas de alta prioridad marcadas",
                    filterByTag: "Â¡Filtra por etiqueta para ver mejoras!", error: "Error",
                    title: "SUGERENCIA DE MEJORA IA", date: "Fecha", issueType: "Tipo de problema", severity: "Gravedad", suggestion: "SUGERENCIA", recommendedAction: "AcciÃ³n recomendada"
                }
            };
            const t = ui[languageCode] || ui["en"];

            // Get Anthropic API key from credentials
            let apiKey = null;
            const storedCreds = credentials.read("anthropic");
            console.log("Credentials check:", storedCreds ? "Found stored credentials" : "No stored credentials");

            if (!storedCreds || !storedCreds.password) {
                // No stored credentials - always prompt (even in headless mode, credentials must be entered at least once)
                console.log("No credentials found, prompting user (required for first run)...");
                const form = new Form();
                const apiKeyField = new Form.Field.Password("apiKey", t.apiKeyLabel, null);
                form.addField(apiKeyField);

                const formPrompt = await form.show(t.apiKeyPrompt, t.continue);
                apiKey = formPrompt.values.apiKey;

                if (!apiKey) {
                    throw new Error(t.apiKeyRequired);
                }

                console.log("Storing new API key in Keychain...");
                credentials.write("anthropic", "api-key", apiKey);
                console.log("API key stored successfully");
            } else if (headless) {
                // Headless mode with stored credentials - use silently
                apiKey = storedCreds.password;
                console.log("Headless: using stored API key");
            } else {
                // Interactive mode - offer to use or clear them
                const alert = new Alert(t.credentialsFound, t.credentialsFoundMsg);
                alert.addOption(t.useStoredKey);
                alert.addOption(t.clearReenter);
                alert.addOption(t.cancel);

                const choice = await alert.show();

                if (choice === 0) {
                    apiKey = storedCreds.password;
                    console.log("Using stored API key");
                } else if (choice === 1) {
                    console.log("Clearing stored credentials...");
                    credentials.remove("anthropic");
                    console.log("Credentials cleared");

                    const form = new Form();
                    const apiKeyField = new Form.Field.Password("apiKey", t.apiKeyLabel, null);
                    form.addField(apiKeyField);

                    const formPrompt = await form.show(t.apiKeyPrompt, t.continue);
                    apiKey = formPrompt.values.apiKey;

                    if (!apiKey) {
                        throw new Error(t.apiKeyRequired);
                    }

                    console.log("Storing new API key in Keychain...");
                    credentials.write("anthropic", "api-key", apiKey);
                    console.log("API key stored successfully");
                } else {
                    console.log("User cancelled");
                    return;
                }
            }

            // Get tasks to analyze
            let tasksToAnalyze = [];
            console.log("Selection check - tasks selected:", selection.tasks.length);

            if (selection.tasks.length > 0) {
                tasksToAnalyze = selection.tasks.filter(task => !task.completed);
                console.log("Using selected tasks, filtered to incomplete:", tasksToAnalyze.length);
            } else if (headless) {
                // Headless mode - use defaultScope preference
                console.log("Headless: using default scope:", defaultScope);
                if (defaultScope === "selected") {
                    throw new Error(t.noTasksSelected);
                } else if (defaultScope === "stale") {
                    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                    tasksToAnalyze = flattenedTasks.filter(task => {
                        return !task.completed && !task.dropped && task.added && task.added < thirtyDaysAgo;
                    });
                    console.log("Headless: analyzing tasks older than 30 days:", tasksToAnalyze.length);
                } else {
                    tasksToAnalyze = flattenedTasks.filter(task => !task.completed && !task.dropped);
                    console.log("Headless: analyzing all incomplete tasks:", tasksToAnalyze.length);
                }
            } else {
                // Interactive mode - show scope selection form
                const form = new Form();
                const scopeField = new Form.Field.Option(
                    "scope", t.analyzeWhich,
                    [t.selectedOnly, t.allIncomplete, t.olderThan30],
                    null, t.allIncomplete
                );
                form.addField(scopeField);

                const formPrompt = await form.show(t.taskScope, t.continue);
                const scope = formPrompt.values.scope;
                console.log("User selected scope:", scope);

                if (scope === t.selectedOnly) {
                    throw new Error(t.noTasksSelected);
                } else if (scope === t.allIncomplete) {
                    tasksToAnalyze = flattenedTasks.filter(task => !task.completed && !task.dropped);
                    console.log("Analyzing all incomplete tasks:", tasksToAnalyze.length);
                } else {
                    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                    tasksToAnalyze = flattenedTasks.filter(task => {
                        return !task.completed && !task.dropped && task.added && task.added < thirtyDaysAgo;
                    });
                    console.log("Analyzing tasks older than 30 days:", tasksToAnalyze.length);
                }
            }

            if (tasksToAnalyze.length === 0) {
                console.log("No tasks found matching criteria");
                if (!headless) {
                    new Alert(t.noTasksFound, t.noTasksFoundMsg).show();
                }
                return;
            }

            console.log("Total tasks to analyze:", tasksToAnalyze.length);

            // Limit to 20 tasks to avoid timeout issues
            if (tasksToAnalyze.length > 20) {
                console.log("Too many tasks, limiting to 20");
                if (!headless) {
                    const alert = new Alert(t.tooManyTasks, `${tasksToAnalyze.length} ${t.tooManyTasksMsg}`);
                    alert.addOption(t.continue);
                    alert.addOption(t.cancel);
                    const choice = await alert.show();
                    if (choice === 1) {
                        console.log("User cancelled due to task limit");
                        return;
                    }
                } else {
                    console.log("Headless: auto-continuing with first 20 tasks");
                }
                tasksToAnalyze = tasksToAnalyze.slice(0, 20);
                console.log("Limited to 20 tasks");
            }

            // Prepare task data for AI analysis
            console.log("Preparing task data for AI analysis...");
            const taskData = tasksToAnalyze.map((task, index) => {
                const age = task.added ? Math.floor((Date.now() - task.added.getTime()) / (1000 * 60 * 60 * 24)) : 0;
                return {
                    index: index,
                    name: task.name,
                    note: task.note ? task.note.substring(0, 200) : "",
                    age_days: age,
                    has_due_date: !!task.dueDate,
                    has_defer_date: !!task.deferDate,
                    flagged: task.flagged,
                    tags: task.tags.map(t => t.name).join(", ")
                };
            });
            console.log("Task data prepared, sample:", JSON.stringify(taskData[0], null, 2));

            // Call Claude API
            console.log("Preparing Claude API request...");
            const request = new URL.FetchRequest();
            request.url = URL.fromString("https://api.anthropic.com/v1/messages");
            request.method = "POST";
            request.headers = {
                "x-api-key": apiKey,
                "anthropic-version": "2023-06-01",
                "Content-Type": "application/json"
            };

            const systemPrompt = `You are a productivity expert analyzing OmniFocus tasks. Identify tasks that are:
1. Vague or non-actionable (e.g., "Think about project" instead of "Draft project proposal outline")
2. Too broad (should be broken into subtasks)
3. Missing critical context
4. Stale (old tasks with no progress)
5. Ambiguous or unclear

For each problematic task, provide:
- Issue type (vague/broad/stale/ambiguous/missing-context)
- Severity (low/medium/high)
- Specific, actionable suggestion for improvement
- Recommended action (clarify/break-down/defer/delete/add-context)

IMPORTANT: Write all suggestions in ${languageName}. The "suggestion" field must be in ${languageName}.

CRITICAL: You must respond with ONLY a valid JSON object. No other text before or after.
Return a JSON object with an "analysis" array. Each item must have: index, issue, severity, suggestion, action.
Example format: {"analysis": [{"index": 0, "issue": "vague", "severity": "high", "suggestion": "...", "action": "clarify"}]}`;

            const requestBody = {
                model: "claude-sonnet-4-20250514",
                max_tokens: 4096,
                system: systemPrompt,
                messages: [
                    { role: "user", content: `Analyze these tasks:\n${JSON.stringify(taskData, null, 2)}` }
                ]
            };

            request.bodyString = JSON.stringify(requestBody);

            console.log("=== Claude API Request ===");
            console.log("URL:", request.url.string);
            console.log("Method:", request.method);
            console.log("API Key (first 20 chars):", apiKey.substring(0, 20) + "...");
            console.log("Headers:", JSON.stringify({
                "x-api-key": "[REDACTED]",
                "anthropic-version": "2023-06-01",
                "Content-Type": "application/json"
            }, null, 2));
            console.log("Request Body:", JSON.stringify(requestBody, null, 2));

            // Show progress
            if (!headless) {
                const progress = new Alert(t.analyzing, t.analyzingMsg);
                progress.show(() => {});
            }

            console.log("Sending request to Claude...");
            console.log("Note: Claude typically responds in 15-30 seconds");

            let response;
            try {
                response = await request.fetch();
            } catch (fetchError) {
                console.error("Fetch error:", fetchError);
                throw new Error(`Network request failed: ${fetchError.message || 'Request timed out'}. Try analyzing fewer tasks (5-10) or check your internet connection.`);
            }

            console.log("=== Claude API Response ===");
            console.log("Status Code:", response.statusCode);
            console.log("Response Body:", response.bodyString);

            if (response.statusCode !== 200) {
                console.error("API Error - Status:", response.statusCode);
                console.error("API Error - Body:", response.bodyString);
                throw new Error(`API Error: ${response.statusCode} - ${response.bodyString}`);
            }

            const data = JSON.parse(response.bodyString);
            console.log("Parsed response data:", JSON.stringify(data, null, 2));

            // Claude returns content array with text blocks
            const textContent = data.content[0].text;

            // Parse JSON from Claude response (with fallback for non-JSON wrapped responses)
            let aiResponse;
            try {
                aiResponse = JSON.parse(textContent);
            } catch (e) {
                // Try to extract JSON from the response if it contains extra text
                const jsonMatch = textContent.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    aiResponse = JSON.parse(jsonMatch[0]);
                } else {
                    throw new Error("Could not parse JSON from Claude response");
                }
            }
            console.log("Parsed AI response:", JSON.stringify(aiResponse, null, 2));

            // Process results - Claude may return different field names
            const issues = aiResponse.results || aiResponse.issues || aiResponse.analysis || [];
            console.log("Issues found:", issues.length);

            if (issues.length === 0) {
                console.log("No issues found, analysis complete");
                if (!headless) {
                    new Alert(t.analysisComplete, t.noIssuesFound).show();
                }
                return;
            }

            // Create or get "AI: Needs Improvement" tag
            console.log("Creating/finding 'AI: Needs Improvement' tag...");
            let improvementTag = tags.byName("AI: Needs Improvement");
            if (!improvementTag) {
                improvementTag = new Tag("AI: Needs Improvement", tags.ending);
                console.log("Created new 'AI: Needs Improvement' tag");
            } else {
                console.log("Found existing 'AI: Needs Improvement' tag");
            }

            // Apply findings to tasks
            console.log("Applying findings to tasks...");
            let updatedCount = 0;
            let flaggedCount = 0;

            issues.forEach((issue, idx) => {
                console.log(`Processing issue ${idx + 1}/${issues.length}:`, JSON.stringify(issue));
                const task = tasksToAnalyze[issue.index];
                if (!task) {
                    console.warn(`Task not found at index ${issue.index}`);
                    return;
                }

                console.log(`Updating task: "${task.name}"`);

                // Build a nicely formatted analysis note (localized)
                const analysisNote = `\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¤– ${t.title}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“… ${t.date}: ${new Date().toLocaleDateString(localeFormatted)}

âš ï¸  ${t.issueType}: ${issue.issue.toUpperCase()}
ğŸ“Š ${t.severity}: ${issue.severity.toUpperCase()}

ğŸ’¡ ${t.suggestion}:
${issue.suggestion}

ğŸ¯ ${t.recommendedAction}: ${issue.action}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

                task.note = (task.note || "") + analysisNote;

                // Add improvement tag
                task.addTag(improvementTag);
                console.log(`Added 'AI: Needs Improvement' tag to task`);

                // Flag high severity issues
                if (issue.severity === "high") {
                    task.flagged = true;
                    flaggedCount++;
                    console.log(`Flagged task due to high severity`);
                }

                updatedCount++;
            });
            console.log(`Updated ${updatedCount} tasks, flagged ${flaggedCount} high-severity tasks`);

            // Show summary
            const summary = `${t.analysisComplete}!\n\n` +
                `${t.tasksAnalyzed}: ${tasksToAnalyze.length}\n` +
                `${t.issuesFound}: ${issues.length}\n` +
                `${t.tasksUpdated}: ${updatedCount}\n` +
                `${t.highSeverityFlagged}: ${flaggedCount}\n\n` +
                `âœ… ${t.taggedWith} "AI: Needs Improvement"\n` +
                `ğŸ“ ${t.suggestionsAdded}\n` +
                `ğŸš© ${t.highSeverityTasksFlagged}\n\n` +
                `${t.filterByTag}`;

            console.log("=== Analysis Summary ===");
            console.log(summary);
            console.log("=== End Debug Log ===");

            if (!headless) {
                new Alert("AI Task Clarifier", summary).show();
            }

        } catch (error) {
            console.error("=== ERROR ===");
            console.error("Error message:", error.message);
            console.error("Error stack:", error.stack);
            console.error("=== End Debug Log ===");
            if (!headless) {
                new Alert(t?.error || "Error", error.message).show();
            }
        }
    });

    action.validate = function(selection, sender) {
        return true; // Always available
    };

    return action;
})();

