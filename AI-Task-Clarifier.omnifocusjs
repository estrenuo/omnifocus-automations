/*{
    "type": "action",
    "targets": ["omnifocus"],
    "author": "OmniFocus Automation",
    "identifier": "com.omnifocus.ai-task-clarifier",
    "version": "1.9.0",
    "description": "Analyzes tasks and projects using AI to identify vague, non-actionable, or problematic items and provides improvement suggestions",
    "label": "AI Task Clarifier",
    "shortLabel": "AI Clarifier",
    "paletteLabel": "Analyze Tasks with AI",
    "image": "wand.and.stars"
}*/
(() => {
    const credentials = new Credentials();

    // === Localization ===
    const LANG_NAMES = {
        en: "English", es: "EspaÃ±ol", fr: "FranÃ§ais", de: "Deutsch",
        it: "Italiano", pt: "PortuguÃªs", ja: "æ—¥æœ¬èª", zh: "ä¸­æ–‡", nl: "Nederlands"
    };

    const STRINGS = {
        en: {
            providerLabel: "AI Provider",
            providerFormTitle: "Choose your AI provider",
            continueButton: "Continue",
            cancelButton: "Cancel",
            credentialsFound: "Credentials Found",
            credentialsFoundMsg: "Stored API key found. What would you like to do?",
            useStoredKey: "Use Stored Key",
            clearReenter: "Clear & Re-enter Key",
            switchProvider: "Switch AI Provider",
            apiKeyLabel: "API Key",
            apiKeyPrompt: "Enter your {provider} API key (will be stored securely in Keychain)",
            apiKeyRequired: "API key is required",
            scopeLabel: "Analyze which tasks?",
            scopeTitle: "Task Analysis Scope",
            scopeSelected: "Selected tasks/projects",
            scopeAll: "All incomplete tasks",
            scopeStale: "Tasks older than 30 days",
            noSelectionError: "No tasks selected. Please select tasks/projects or choose a different scope.",
            noTasksTitle: "No Tasks Found",
            noTasksMsg: "No tasks match the selected criteria.",
            tooManyTitle: "Too Many Tasks",
            tooManyMsg: "Found {count} items. Will analyze the first 20 only to avoid timeouts.",
            analyzingTitle: "Analyzing Tasks",
            analyzingMsg: "Sending tasks to {provider} for analysis...\n\nThis may take 15-30 seconds.",
            completeTitle: "Analysis Complete",
            noIssuesMsg: "No significant issues found! Your tasks look good.",
            summaryTitle: "AI Task Clarifier",
            summaryItemsAnalyzed: "Items analyzed",
            summaryIssuesFound: "Issues found",
            summaryItemsUpdated: "Items updated",
            summaryFlagged: "High-severity flagged",
            summaryTagLine: 'Tagged with "AI: Needs Improvement"',
            summaryNoteLine: "Suggestions added to task notes",
            summaryFlagLine: "High-severity tasks flagged",
            summaryFilterTip: "Filter by tag to review improvements!",
            errorTitle: "Error",
            noteHeader: "AI IMPROVEMENT SUGGESTION",
            noteDate: "Date",
            noteIssueType: "Issue Type",
            noteSeverity: "Severity",
            noteSuggestion: "SUGGESTION",
            noteAction: "Recommended Action",
            tagName: "AI: Needs Improvement"
        },
        es: {
            providerLabel: "Proveedor de IA",
            providerFormTitle: "Elige tu proveedor de IA",
            continueButton: "Continuar",
            cancelButton: "Cancelar",
            credentialsFound: "Credenciales encontradas",
            credentialsFoundMsg: "Se encontrÃ³ una clave API almacenada. Â¿QuÃ© deseas hacer?",
            useStoredKey: "Usar clave guardada",
            clearReenter: "Borrar y volver a ingresar",
            switchProvider: "Cambiar proveedor de IA",
            apiKeyLabel: "Clave API",
            apiKeyPrompt: "Ingresa tu clave API de {provider} (se almacenarÃ¡ de forma segura en el Llavero)",
            apiKeyRequired: "La clave API es obligatoria",
            scopeLabel: "Â¿QuÃ© tareas analizar?",
            scopeTitle: "Alcance del anÃ¡lisis",
            scopeSelected: "Tareas/proyectos seleccionados",
            scopeAll: "Todas las tareas pendientes",
            scopeStale: "Tareas con mÃ¡s de 30 dÃ­as",
            noSelectionError: "No hay tareas seleccionadas. Selecciona tareas/proyectos o elige otro alcance.",
            noTasksTitle: "Sin tareas",
            noTasksMsg: "Ninguna tarea coincide con los criterios seleccionados.",
            tooManyTitle: "Demasiadas tareas",
            tooManyMsg: "Se encontraron {count} elementos. Solo se analizarÃ¡n los primeros 20 para evitar tiempos de espera.",
            analyzingTitle: "Analizando tareas",
            analyzingMsg: "Enviando tareas a {provider} para anÃ¡lisis...\n\nEsto puede tardar 15-30 segundos.",
            completeTitle: "AnÃ¡lisis completado",
            noIssuesMsg: "Â¡No se encontraron problemas significativos! Tus tareas se ven bien.",
            summaryTitle: "AI Task Clarifier",
            summaryItemsAnalyzed: "Elementos analizados",
            summaryIssuesFound: "Problemas encontrados",
            summaryItemsUpdated: "Elementos actualizados",
            summaryFlagged: "Marcados de alta gravedad",
            summaryTagLine: 'Etiquetados con "AI: Needs Improvement"',
            summaryNoteLine: "Sugerencias aÃ±adidas a las notas",
            summaryFlagLine: "Tareas de alta gravedad marcadas",
            summaryFilterTip: "Â¡Filtra por etiqueta para revisar las mejoras!",
            errorTitle: "Error",
            noteHeader: "SUGERENCIA DE MEJORA IA",
            noteDate: "Fecha",
            noteIssueType: "Tipo de problema",
            noteSeverity: "Gravedad",
            noteSuggestion: "SUGERENCIA",
            noteAction: "AcciÃ³n recomendada",
            tagName: "AI: Needs Improvement"
        },
        fr: {
            providerLabel: "Fournisseur IA",
            providerFormTitle: "Choisissez votre fournisseur IA",
            continueButton: "Continuer",
            cancelButton: "Annuler",
            credentialsFound: "Identifiants trouvÃ©s",
            credentialsFoundMsg: "ClÃ© API stockÃ©e trouvÃ©e. Que souhaitez-vous faire ?",
            useStoredKey: "Utiliser la clÃ© stockÃ©e",
            clearReenter: "Effacer et ressaisir",
            switchProvider: "Changer de fournisseur IA",
            apiKeyLabel: "ClÃ© API",
            apiKeyPrompt: "Entrez votre clÃ© API {provider} (sera stockÃ©e de maniÃ¨re sÃ©curisÃ©e dans le Trousseau)",
            apiKeyRequired: "La clÃ© API est requise",
            scopeLabel: "Quelles tÃ¢ches analyser ?",
            scopeTitle: "PortÃ©e de l'analyse",
            scopeSelected: "TÃ¢ches/projets sÃ©lectionnÃ©s",
            scopeAll: "Toutes les tÃ¢ches en cours",
            scopeStale: "TÃ¢ches de plus de 30 jours",
            noSelectionError: "Aucune tÃ¢che sÃ©lectionnÃ©e. SÃ©lectionnez des tÃ¢ches/projets ou choisissez une autre portÃ©e.",
            noTasksTitle: "Aucune tÃ¢che trouvÃ©e",
            noTasksMsg: "Aucune tÃ¢che ne correspond aux critÃ¨res sÃ©lectionnÃ©s.",
            tooManyTitle: "Trop de tÃ¢ches",
            tooManyMsg: "TrouvÃ© {count} Ã©lÃ©ments. Seuls les 20 premiers seront analysÃ©s pour Ã©viter les dÃ©lais.",
            analyzingTitle: "Analyse des tÃ¢ches",
            analyzingMsg: "Envoi des tÃ¢ches Ã  {provider} pour analyse...\n\nCela peut prendre 15 Ã  30 secondes.",
            completeTitle: "Analyse terminÃ©e",
            noIssuesMsg: "Aucun problÃ¨me significatif trouvÃ© ! Vos tÃ¢ches sont en bon Ã©tat.",
            summaryTitle: "AI Task Clarifier",
            summaryItemsAnalyzed: "Ã‰lÃ©ments analysÃ©s",
            summaryIssuesFound: "ProblÃ¨mes trouvÃ©s",
            summaryItemsUpdated: "Ã‰lÃ©ments mis Ã  jour",
            summaryFlagged: "SignalÃ©s haute gravitÃ©",
            summaryTagLine: 'Ã‰tiquetÃ©s avec "AI: Needs Improvement"',
            summaryNoteLine: "Suggestions ajoutÃ©es aux notes",
            summaryFlagLine: "TÃ¢ches haute gravitÃ© signalÃ©es",
            summaryFilterTip: "Filtrez par Ã©tiquette pour examiner les amÃ©liorations !",
            errorTitle: "Erreur",
            noteHeader: "SUGGESTION D'AMÃ‰LIORATION IA",
            noteDate: "Date",
            noteIssueType: "Type de problÃ¨me",
            noteSeverity: "GravitÃ©",
            noteSuggestion: "SUGGESTION",
            noteAction: "Action recommandÃ©e",
            tagName: "AI: Needs Improvement"
        },
        de: {
            providerLabel: "KI-Anbieter",
            providerFormTitle: "WÃ¤hlen Sie Ihren KI-Anbieter",
            continueButton: "Weiter",
            cancelButton: "Abbrechen",
            credentialsFound: "Zugangsdaten gefunden",
            credentialsFoundMsg: "Gespeicherter API-SchlÃ¼ssel gefunden. Was mÃ¶chten Sie tun?",
            useStoredKey: "Gespeicherten SchlÃ¼ssel verwenden",
            clearReenter: "LÃ¶schen und neu eingeben",
            switchProvider: "KI-Anbieter wechseln",
            apiKeyLabel: "API-SchlÃ¼ssel",
            apiKeyPrompt: "Geben Sie Ihren {provider} API-SchlÃ¼ssel ein (wird sicher im SchlÃ¼sselbund gespeichert)",
            apiKeyRequired: "API-SchlÃ¼ssel ist erforderlich",
            scopeLabel: "Welche Aufgaben analysieren?",
            scopeTitle: "Analyseumfang",
            scopeSelected: "AusgewÃ¤hlte Aufgaben/Projekte",
            scopeAll: "Alle offenen Aufgaben",
            scopeStale: "Aufgaben Ã¤lter als 30 Tage",
            noSelectionError: "Keine Aufgaben ausgewÃ¤hlt. Bitte wÃ¤hlen Sie Aufgaben/Projekte oder einen anderen Umfang.",
            noTasksTitle: "Keine Aufgaben gefunden",
            noTasksMsg: "Keine Aufgaben entsprechen den ausgewÃ¤hlten Kriterien.",
            tooManyTitle: "Zu viele Aufgaben",
            tooManyMsg: "Es wurden {count} Elemente gefunden. Nur die ersten 20 werden analysiert.",
            analyzingTitle: "Aufgaben werden analysiert",
            analyzingMsg: "Aufgaben werden an {provider} zur Analyse gesendet...\n\nDies kann 15-30 Sekunden dauern.",
            completeTitle: "Analyse abgeschlossen",
            noIssuesMsg: "Keine wesentlichen Probleme gefunden! Ihre Aufgaben sehen gut aus.",
            summaryTitle: "AI Task Clarifier",
            summaryItemsAnalyzed: "Analysierte Elemente",
            summaryIssuesFound: "Gefundene Probleme",
            summaryItemsUpdated: "Aktualisierte Elemente",
            summaryFlagged: "Hohe PrioritÃ¤t markiert",
            summaryTagLine: 'Markiert mit "AI: Needs Improvement"',
            summaryNoteLine: "VorschlÃ¤ge in Notizen hinzugefÃ¼gt",
            summaryFlagLine: "Aufgaben hoher PrioritÃ¤t markiert",
            summaryFilterTip: "Filtern Sie nach Tag, um die Verbesserungen zu Ã¼berprÃ¼fen!",
            errorTitle: "Fehler",
            noteHeader: "KI-VERBESSERUNGSVORSCHLAG",
            noteDate: "Datum",
            noteIssueType: "Problemtyp",
            noteSeverity: "Schweregrad",
            noteSuggestion: "VORSCHLAG",
            noteAction: "Empfohlene MaÃŸnahme",
            tagName: "AI: Needs Improvement"
        },
        it: {
            providerLabel: "Provider IA",
            providerFormTitle: "Scegli il tuo provider IA",
            continueButton: "Continua",
            cancelButton: "Annulla",
            credentialsFound: "Credenziali trovate",
            credentialsFoundMsg: "Chiave API memorizzata trovata. Cosa vuoi fare?",
            useStoredKey: "Usa chiave memorizzata",
            clearReenter: "Cancella e reinserisci",
            switchProvider: "Cambia provider IA",
            apiKeyLabel: "Chiave API",
            apiKeyPrompt: "Inserisci la tua chiave API {provider} (verrÃ  memorizzata in modo sicuro nel Portachiavi)",
            apiKeyRequired: "La chiave API Ã¨ obbligatoria",
            scopeLabel: "Quali attivitÃ  analizzare?",
            scopeTitle: "Ambito di analisi",
            scopeSelected: "AttivitÃ /progetti selezionati",
            scopeAll: "Tutte le attivitÃ  in corso",
            scopeStale: "AttivitÃ  piÃ¹ vecchie di 30 giorni",
            noSelectionError: "Nessuna attivitÃ  selezionata. Seleziona attivitÃ /progetti o scegli un altro ambito.",
            noTasksTitle: "Nessuna attivitÃ  trovata",
            noTasksMsg: "Nessuna attivitÃ  corrisponde ai criteri selezionati.",
            tooManyTitle: "Troppe attivitÃ ",
            tooManyMsg: "Trovati {count} elementi. Verranno analizzati solo i primi 20.",
            analyzingTitle: "Analisi attivitÃ ",
            analyzingMsg: "Invio attivitÃ  a {provider} per l'analisi...\n\nPotrebbe richiedere 15-30 secondi.",
            completeTitle: "Analisi completata",
            noIssuesMsg: "Nessun problema significativo trovato! Le tue attivitÃ  sono in ordine.",
            summaryTitle: "AI Task Clarifier",
            summaryItemsAnalyzed: "Elementi analizzati",
            summaryIssuesFound: "Problemi trovati",
            summaryItemsUpdated: "Elementi aggiornati",
            summaryFlagged: "Alta gravitÃ  segnalati",
            summaryTagLine: 'Etichettati con "AI: Needs Improvement"',
            summaryNoteLine: "Suggerimenti aggiunti alle note",
            summaryFlagLine: "AttivitÃ  ad alta gravitÃ  segnalate",
            summaryFilterTip: "Filtra per etichetta per rivedere i miglioramenti!",
            errorTitle: "Errore",
            noteHeader: "SUGGERIMENTO DI MIGLIORAMENTO IA",
            noteDate: "Data",
            noteIssueType: "Tipo di problema",
            noteSeverity: "GravitÃ ",
            noteSuggestion: "SUGGERIMENTO",
            noteAction: "Azione raccomandata",
            tagName: "AI: Needs Improvement"
        },
        pt: {
            providerLabel: "Provedor de IA",
            providerFormTitle: "Escolha seu provedor de IA",
            continueButton: "Continuar",
            cancelButton: "Cancelar",
            credentialsFound: "Credenciais encontradas",
            credentialsFoundMsg: "Chave API armazenada encontrada. O que deseja fazer?",
            useStoredKey: "Usar chave armazenada",
            clearReenter: "Limpar e reinserir",
            switchProvider: "Trocar provedor de IA",
            apiKeyLabel: "Chave API",
            apiKeyPrompt: "Insira sua chave API {provider} (serÃ¡ armazenada com seguranÃ§a nas Chaves)",
            apiKeyRequired: "A chave API Ã© obrigatÃ³ria",
            scopeLabel: "Quais tarefas analisar?",
            scopeTitle: "Escopo da anÃ¡lise",
            scopeSelected: "Tarefas/projetos selecionados",
            scopeAll: "Todas as tarefas pendentes",
            scopeStale: "Tarefas com mais de 30 dias",
            noSelectionError: "Nenhuma tarefa selecionada. Selecione tarefas/projetos ou escolha outro escopo.",
            noTasksTitle: "Nenhuma tarefa encontrada",
            noTasksMsg: "Nenhuma tarefa corresponde aos critÃ©rios selecionados.",
            tooManyTitle: "Muitas tarefas",
            tooManyMsg: "Encontrados {count} itens. Apenas os primeiros 20 serÃ£o analisados.",
            analyzingTitle: "Analisando tarefas",
            analyzingMsg: "Enviando tarefas para {provider} para anÃ¡lise...\n\nIsso pode levar 15-30 segundos.",
            completeTitle: "AnÃ¡lise concluÃ­da",
            noIssuesMsg: "Nenhum problema significativo encontrado! Suas tarefas estÃ£o em ordem.",
            summaryTitle: "AI Task Clarifier",
            summaryItemsAnalyzed: "Itens analisados",
            summaryIssuesFound: "Problemas encontrados",
            summaryItemsUpdated: "Itens atualizados",
            summaryFlagged: "Alta gravidade sinalizados",
            summaryTagLine: 'Etiquetados com "AI: Needs Improvement"',
            summaryNoteLine: "SugestÃµes adicionadas Ã s notas",
            summaryFlagLine: "Tarefas de alta gravidade sinalizadas",
            summaryFilterTip: "Filtre por etiqueta para revisar as melhorias!",
            errorTitle: "Erro",
            noteHeader: "SUGESTÃƒO DE MELHORIA IA",
            noteDate: "Data",
            noteIssueType: "Tipo de problema",
            noteSeverity: "Gravidade",
            noteSuggestion: "SUGESTÃƒO",
            noteAction: "AÃ§Ã£o recomendada",
            tagName: "AI: Needs Improvement"
        },
        ja: {
            providerLabel: "AIãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼",
            providerFormTitle: "AIãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„",
            continueButton: "ç¶šè¡Œ",
            cancelButton: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
            credentialsFound: "èªè¨¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ",
            credentialsFoundMsg: "ä¿å­˜ã•ã‚ŒãŸAPIã‚­ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ã©ã†ã—ã¾ã™ã‹ï¼Ÿ",
            useStoredKey: "ä¿å­˜ã•ã‚ŒãŸã‚­ãƒ¼ã‚’ä½¿ç”¨",
            clearReenter: "å‰Šé™¤ã—ã¦å†å…¥åŠ›",
            switchProvider: "AIãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‚’åˆ‡æ›¿",
            apiKeyLabel: "APIã‚­ãƒ¼",
            apiKeyPrompt: "{provider}ã®APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆã‚­ãƒ¼ãƒã‚§ãƒ¼ãƒ³ã«å®‰å…¨ã«ä¿å­˜ã•ã‚Œã¾ã™ï¼‰",
            apiKeyRequired: "APIã‚­ãƒ¼ã¯å¿…é ˆã§ã™",
            scopeLabel: "ã©ã®ã‚¿ã‚¹ã‚¯ã‚’åˆ†æã—ã¾ã™ã‹ï¼Ÿ",
            scopeTitle: "åˆ†æç¯„å›²",
            scopeSelected: "é¸æŠã—ãŸã‚¿ã‚¹ã‚¯/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ",
            scopeAll: "ã™ã¹ã¦ã®æœªå®Œäº†ã‚¿ã‚¹ã‚¯",
            scopeStale: "30æ—¥ä»¥ä¸Šå‰ã®ã‚¿ã‚¹ã‚¯",
            noSelectionError: "ã‚¿ã‚¹ã‚¯ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚¿ã‚¹ã‚¯/ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é¸æŠã™ã‚‹ã‹ã€åˆ¥ã®ç¯„å›²ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚",
            noTasksTitle: "ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
            noTasksMsg: "é¸æŠã—ãŸæ¡ä»¶ã«ä¸€è‡´ã™ã‚‹ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã€‚",
            tooManyTitle: "ã‚¿ã‚¹ã‚¯ãŒå¤šã™ãã¾ã™",
            tooManyMsg: "{count}ä»¶ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’é¿ã‘ã‚‹ãŸã‚ã€æœ€åˆã®20ä»¶ã®ã¿åˆ†æã—ã¾ã™ã€‚",
            analyzingTitle: "ã‚¿ã‚¹ã‚¯ã‚’åˆ†æä¸­",
            analyzingMsg: "ã‚¿ã‚¹ã‚¯ã‚’{provider}ã«é€ä¿¡ã—ã¦åˆ†æä¸­...\n\n15ã€œ30ç§’ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚",
            completeTitle: "åˆ†æå®Œäº†",
            noIssuesMsg: "é‡å¤§ãªå•é¡Œã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼ã‚¿ã‚¹ã‚¯ã¯è‰¯å¥½ã§ã™ã€‚",
            summaryTitle: "AI Task Clarifier",
            summaryItemsAnalyzed: "åˆ†æã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ",
            summaryIssuesFound: "ç™ºè¦‹ã•ã‚ŒãŸå•é¡Œ",
            summaryItemsUpdated: "æ›´æ–°ã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ",
            summaryFlagged: "é«˜é‡å¤§åº¦ã®ãƒ•ãƒ©ã‚°",
            summaryTagLine: '"AI: Needs Improvement" ã§ã‚¿ã‚°ä»˜ã‘',
            summaryNoteLine: "ã‚¿ã‚¹ã‚¯ã®ãƒ¡ãƒ¢ã«ææ¡ˆã‚’è¿½åŠ ",
            summaryFlagLine: "é«˜é‡å¤§åº¦ã‚¿ã‚¹ã‚¯ã«ãƒ•ãƒ©ã‚°ä»˜ã‘",
            summaryFilterTip: "ã‚¿ã‚°ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã—ã¦æ”¹å–„ç‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼",
            errorTitle: "ã‚¨ãƒ©ãƒ¼",
            noteHeader: "AIæ”¹å–„ææ¡ˆ",
            noteDate: "æ—¥ä»˜",
            noteIssueType: "å•é¡Œã®ç¨®é¡",
            noteSeverity: "é‡å¤§åº¦",
            noteSuggestion: "ææ¡ˆ",
            noteAction: "æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³",
            tagName: "AI: Needs Improvement"
        },
        zh: {
            providerLabel: "AI æä¾›å•†",
            providerFormTitle: "é€‰æ‹©æ‚¨çš„ AI æä¾›å•†",
            continueButton: "ç»§ç»­",
            cancelButton: "å–æ¶ˆ",
            credentialsFound: "å·²æ‰¾åˆ°å‡­æ®",
            credentialsFoundMsg: "å·²æ‰¾åˆ°å­˜å‚¨çš„ API å¯†é’¥ã€‚æ‚¨æƒ³æ€ä¹ˆåšï¼Ÿ",
            useStoredKey: "ä½¿ç”¨å·²å­˜å‚¨çš„å¯†é’¥",
            clearReenter: "æ¸…é™¤å¹¶é‡æ–°è¾“å…¥",
            switchProvider: "åˆ‡æ¢ AI æä¾›å•†",
            apiKeyLabel: "API å¯†é’¥",
            apiKeyPrompt: "è¾“å…¥æ‚¨çš„ {provider} API å¯†é’¥ï¼ˆå°†å®‰å…¨å­˜å‚¨åœ¨é’¥åŒ™ä¸²ä¸­ï¼‰",
            apiKeyRequired: "API å¯†é’¥æ˜¯å¿…å¡«é¡¹",
            scopeLabel: "åˆ†æå“ªäº›ä»»åŠ¡ï¼Ÿ",
            scopeTitle: "åˆ†æèŒƒå›´",
            scopeSelected: "å·²é€‰æ‹©çš„ä»»åŠ¡/é¡¹ç›®",
            scopeAll: "æ‰€æœ‰æœªå®Œæˆçš„ä»»åŠ¡",
            scopeStale: "è¶…è¿‡30å¤©çš„ä»»åŠ¡",
            noSelectionError: "æœªé€‰æ‹©ä»»åŠ¡ã€‚è¯·é€‰æ‹©ä»»åŠ¡/é¡¹ç›®æˆ–é€‰æ‹©å…¶ä»–èŒƒå›´ã€‚",
            noTasksTitle: "æœªæ‰¾åˆ°ä»»åŠ¡",
            noTasksMsg: "æ²¡æœ‰ç¬¦åˆæ‰€é€‰æ¡ä»¶çš„ä»»åŠ¡ã€‚",
            tooManyTitle: "ä»»åŠ¡è¿‡å¤š",
            tooManyMsg: "æ‰¾åˆ° {count} ä¸ªé¡¹ç›®ã€‚ä¸ºé¿å…è¶…æ—¶ï¼Œä»…åˆ†æå‰20ä¸ªã€‚",
            analyzingTitle: "æ­£åœ¨åˆ†æä»»åŠ¡",
            analyzingMsg: "æ­£åœ¨å°†ä»»åŠ¡å‘é€åˆ° {provider} è¿›è¡Œåˆ†æ...\n\nè¿™å¯èƒ½éœ€è¦15-30ç§’ã€‚",
            completeTitle: "åˆ†æå®Œæˆ",
            noIssuesMsg: "æœªå‘ç°é‡å¤§é—®é¢˜ï¼æ‚¨çš„ä»»åŠ¡çŠ¶å†µè‰¯å¥½ã€‚",
            summaryTitle: "AI Task Clarifier",
            summaryItemsAnalyzed: "å·²åˆ†æé¡¹ç›®",
            summaryIssuesFound: "å‘ç°çš„é—®é¢˜",
            summaryItemsUpdated: "å·²æ›´æ–°é¡¹ç›®",
            summaryFlagged: "é«˜ä¸¥é‡æ€§æ ‡è®°",
            summaryTagLine: 'å·²æ ‡è®° "AI: Needs Improvement"',
            summaryNoteLine: "å»ºè®®å·²æ·»åŠ åˆ°ä»»åŠ¡å¤‡æ³¨",
            summaryFlagLine: "é«˜ä¸¥é‡æ€§ä»»åŠ¡å·²æ ‡è®°",
            summaryFilterTip: "æŒ‰æ ‡ç­¾ç­›é€‰ä»¥æŸ¥çœ‹æ”¹è¿›å»ºè®®ï¼",
            errorTitle: "é”™è¯¯",
            noteHeader: "AI æ”¹è¿›å»ºè®®",
            noteDate: "æ—¥æœŸ",
            noteIssueType: "é—®é¢˜ç±»å‹",
            noteSeverity: "ä¸¥é‡ç¨‹åº¦",
            noteSuggestion: "å»ºè®®",
            noteAction: "å»ºè®®æ“ä½œ",
            tagName: "AI: Needs Improvement"
        },
        nl: {
            providerLabel: "AI-provider",
            providerFormTitle: "Kies je AI-provider",
            continueButton: "Doorgaan",
            cancelButton: "Annuleren",
            credentialsFound: "Inloggegevens gevonden",
            credentialsFoundMsg: "Opgeslagen API-sleutel gevonden. Wat wil je doen?",
            useStoredKey: "Opgeslagen sleutel gebruiken",
            clearReenter: "Wissen en opnieuw invoeren",
            switchProvider: "Wissel van AI-provider",
            apiKeyLabel: "API-sleutel",
            apiKeyPrompt: "Voer je {provider} API-sleutel in (wordt veilig opgeslagen in de Sleutelhanger)",
            apiKeyRequired: "API-sleutel is vereist",
            scopeLabel: "Welke taken analyseren?",
            scopeTitle: "Analysebereik",
            scopeSelected: "Geselecteerde taken/projecten",
            scopeAll: "Alle openstaande taken",
            scopeStale: "Taken ouder dan 30 dagen",
            noSelectionError: "Geen taken geselecteerd. Selecteer taken/projecten of kies een ander bereik.",
            noTasksTitle: "Geen taken gevonden",
            noTasksMsg: "Geen taken voldoen aan de geselecteerde criteria.",
            tooManyTitle: "Te veel taken",
            tooManyMsg: "{count} items gevonden. Alleen de eerste 20 worden geanalyseerd om time-outs te voorkomen.",
            analyzingTitle: "Taken analyseren",
            analyzingMsg: "Taken worden naar {provider} gestuurd voor analyse...\n\nDit kan 15-30 seconden duren.",
            completeTitle: "Analyse voltooid",
            noIssuesMsg: "Geen significante problemen gevonden! Je taken zien er goed uit.",
            summaryTitle: "AI Task Clarifier",
            summaryItemsAnalyzed: "Geanalyseerde items",
            summaryIssuesFound: "Gevonden problemen",
            summaryItemsUpdated: "Bijgewerkte items",
            summaryFlagged: "Hoge ernst gemarkeerd",
            summaryTagLine: 'Getagd met "AI: Needs Improvement"',
            summaryNoteLine: "Suggesties toegevoegd aan notities",
            summaryFlagLine: "Taken met hoge ernst gemarkeerd",
            summaryFilterTip: "Filter op tag om verbeteringen te bekijken!",
            errorTitle: "Fout",
            noteHeader: "AI VERBETERINGSVOORSTEL",
            noteDate: "Datum",
            noteIssueType: "Probleemtype",
            noteSeverity: "Ernst",
            noteSuggestion: "VOORSTEL",
            noteAction: "Aanbevolen actie",
            tagName: "AI: Needs Improvement"
        }
    };

    function getSystemLanguage() {
        try {
            const locale = Intl.DateTimeFormat().resolvedOptions().locale;
            return locale ? locale.split("-")[0].toLowerCase() : "en";
        } catch (e) {
            return "en";
        }
    }

    function getEffectiveLanguage() {
        const prefs = new Preferences("com.omnifocus.headless-settings");
        const override = prefs.readString("language");
        if (override && override !== "auto") {
            return STRINGS[override] ? override : "en";
        }
        const detected = getSystemLanguage();
        return STRINGS[detected] ? detected : "en";
    }

    function t(key, replacements) {
        const lang = getEffectiveLanguage();
        let str = (STRINGS[lang] && STRINGS[lang][key]) || STRINGS.en[key] || key;
        if (replacements) {
            for (const [k, v] of Object.entries(replacements)) {
                str = str.replace(`{${k}}`, v);
            }
        }
        return str;
    }

    const AI_PROVIDERS = {
        chatgpt: {
            label: "ChatGPT (OpenAI)",
            credentialService: "openai",
            buildRequest(apiKey, systemPrompt, userMessage) {
                const request = new URL.FetchRequest();
                request.url = URL.fromString("https://api.openai.com/v1/chat/completions");
                request.method = "POST";
                request.headers = {
                    "Authorization": `Bearer ${apiKey}`,
                    "Content-Type": "application/json"
                };
                request.bodyString = JSON.stringify({
                    model: "gpt-5-2025-08-07",
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: userMessage }
                    ],
                    response_format: { type: "json_object" }
                });
                return request;
            },
            parseResponse(responseBody) {
                const data = JSON.parse(responseBody);
                return JSON.parse(data.choices[0].message.content);
            }
        },
        claude: {
            label: "Claude (Anthropic)",
            credentialService: "anthropic",
            buildRequest(apiKey, systemPrompt, userMessage) {
                const request = new URL.FetchRequest();
                request.url = URL.fromString("https://api.anthropic.com/v1/messages");
                request.method = "POST";
                request.headers = {
                    "x-api-key": apiKey,
                    "anthropic-version": "2023-06-01",
                    "Content-Type": "application/json"
                };
                request.bodyString = JSON.stringify({
                    model: "claude-sonnet-4-20250514",
                    max_tokens: 4096,
                    system: systemPrompt + "\n\nIMPORTANT: Respond with only a valid JSON object, no other text.",
                    messages: [
                        { role: "user", content: userMessage }
                    ]
                });
                return request;
            },
            parseResponse(responseBody) {
                const data = JSON.parse(responseBody);
                const text = data.content[0].text;
                try {
                    return JSON.parse(text);
                } catch (e) {
                    const match = text.match(/\{[\s\S]*\}/);
                    if (match) {
                        return JSON.parse(match[0]);
                    }
                    throw new Error("Failed to parse AI response as JSON");
                }
            }
        }
    };

    async function callAI(providerKey, apiKey, systemPrompt, userMessage) {
        const provider = AI_PROVIDERS[providerKey];
        console.log(`Calling ${provider.label} API...`);

        const request = provider.buildRequest(apiKey, systemPrompt, userMessage);

        console.log("=== AI API Request ===");
        console.log("URL:", request.url.string);
        console.log("Method:", request.method);
        console.log("API Key (first 20 chars):", apiKey.substring(0, 20) + "...");

        let response;
        try {
            response = await request.fetch();
        } catch (fetchError) {
            console.error("Fetch error:", fetchError);
            throw new Error(`Network request failed: ${fetchError.message || 'Request timed out'}. Check your internet connection.`);
        }

        console.log("=== AI API Response ===");
        console.log("Status Code:", response.statusCode);
        console.log("Response Body:", response.bodyString);

        if (response.statusCode !== 200) {
            console.error("API Error - Status:", response.statusCode);
            console.error("API Error - Body:", response.bodyString);
            throw new Error(`API Error: ${response.statusCode} - ${response.bodyString}`);
        }

        const parsed = provider.parseResponse(response.bodyString);
        console.log("Parsed AI response:", JSON.stringify(parsed, null, 2));
        return parsed;
    }

    const action = new PlugIn.Action(async function(selection, sender) {
        try {
            console.log("=== AI Task Clarifier Debug Log ===");
            console.log("Starting plugin execution...");

            // Headless mode: skip all dialogs, use stored credentials and defaults
            const prefs = new Preferences("com.omnifocus.ai-task-clarifier");
            const headless = prefs.readBoolean("headlessMode");
            const defaultScope = prefs.readString("defaultScope") || "all";
            console.log("Headless mode:", headless, "Default scope:", defaultScope);

            // --- Provider selection ---
            let providerKey = prefs.readString("aiProvider");
            let provider = providerKey ? AI_PROVIDERS[providerKey] : null;

            if (!provider) {
                if (headless) {
                    providerKey = "chatgpt";
                    provider = AI_PROVIDERS[providerKey];
                    console.log("Headless: defaulting to ChatGPT");
                } else {
                    const providerForm = new Form();
                    providerForm.addField(new Form.Field.Option(
                        "aiProvider",
                        t("providerLabel"),
                        ["chatgpt", "claude"],
                        ["ChatGPT (OpenAI)", "Claude (Anthropic)"],
                        "chatgpt"
                    ));
                    const providerResult = await providerForm.show(t("providerFormTitle"), t("continueButton"));
                    providerKey = providerResult.values.aiProvider;
                    provider = AI_PROVIDERS[providerKey];
                    prefs.write("aiProvider", providerKey);
                    console.log("User selected provider:", providerKey);
                }
            }

            // --- Credential flow ---
            let apiKey = null;
            const storedCreds = credentials.read(provider.credentialService);
            console.log("Credentials check:", storedCreds ? "Found stored credentials" : "No stored credentials");

            if (!storedCreds || !storedCreds.password) {
                console.log("No credentials found, prompting user (required for first run)...");
                const form = new Form();
                form.addField(new Form.Field.Password("apiKey", `${provider.label} ${t("apiKeyLabel")}`, null));
                const formPrompt = await form.show(t("apiKeyPrompt", {provider: provider.label}), t("continueButton"));
                apiKey = formPrompt.values.apiKey;
                if (!apiKey) {
                    throw new Error(t("apiKeyRequired"));
                }
                console.log("Storing new API key in Keychain...");
                credentials.write(provider.credentialService, "api-key", apiKey);
                console.log("API key stored successfully");
            } else if (headless) {
                apiKey = storedCreds.password;
                console.log("Headless: using stored API key");
            } else {
                const alert = new Alert(`${provider.label} â€” ${t("credentialsFound")}`, t("credentialsFoundMsg"));
                alert.addOption(t("useStoredKey"));
                alert.addOption(t("clearReenter"));
                alert.addOption(t("switchProvider"));
                alert.addOption(t("cancelButton"));

                const choice = await alert.show();

                if (choice === 0) {
                    apiKey = storedCreds.password;
                    console.log("Using stored API key");
                } else if (choice === 1) {
                    console.log("Clearing stored credentials...");
                    credentials.remove(provider.credentialService);
                    const form = new Form();
                    form.addField(new Form.Field.Password("apiKey", `${provider.label} ${t("apiKeyLabel")}`, null));
                    const formPrompt = await form.show(t("apiKeyPrompt", {provider: provider.label}), t("continueButton"));
                    apiKey = formPrompt.values.apiKey;
                    if (!apiKey) {
                        throw new Error(t("apiKeyRequired"));
                    }
                    console.log("Storing new API key in Keychain...");
                    credentials.write(provider.credentialService, "api-key", apiKey);
                    console.log("API key stored successfully");
                } else if (choice === 2) {
                    const otherKey = providerKey === "chatgpt" ? "claude" : "chatgpt";
                    providerKey = otherKey;
                    provider = AI_PROVIDERS[providerKey];
                    prefs.write("aiProvider", providerKey);
                    console.log("Switched to provider:", providerKey);

                    const switchedCreds = credentials.read(provider.credentialService);
                    if (switchedCreds && switchedCreds.password) {
                        apiKey = switchedCreds.password;
                        console.log("Using stored key for", provider.label);
                    } else {
                        const form = new Form();
                        form.addField(new Form.Field.Password("apiKey", `${provider.label} ${t("apiKeyLabel")}`, null));
                        const formPrompt = await form.show(t("apiKeyPrompt", {provider: provider.label}), t("continueButton"));
                        apiKey = formPrompt.values.apiKey;
                        if (!apiKey) {
                            throw new Error(t("apiKeyRequired"));
                        }
                        credentials.write(provider.credentialService, "api-key", apiKey);
                        console.log("Stored new key for", provider.label);
                    }
                } else {
                    console.log("User cancelled");
                    return;
                }
            }

            // Get items to analyze (tasks and/or projects)
            let analyzeItems = []; // [{item, type: 'task'|'project'}, ...]
            console.log("Selection check - tasks selected:", selection.tasks.length, "projects selected:", selection.projects.length);

            // Collect items from the selection
            if (selection.tasks.length > 0 || selection.projects.length > 0) {
                const seen = new Set();
                for (const task of selection.tasks) {
                    if (!seen.has(task.id.primaryKey) && !task.completed) {
                        seen.add(task.id.primaryKey);
                        analyzeItems.push({item: task, type: 'task'});
                    }
                }
                for (const project of selection.projects) {
                    analyzeItems.push({item: project, type: 'project'});
                }
                console.log("Items from selection:", analyzeItems.length, "(tasks:", analyzeItems.filter(e => e.type === 'task').length, "projects:", analyzeItems.filter(e => e.type === 'project').length + ")");
            }

            // If selection yielded no items, fall back to scope selection
            if (analyzeItems.length === 0) {
                let scopeTasks = [];
                if (headless) {
                    console.log("Headless: using default scope:", defaultScope);
                    if (defaultScope === "selected") {
                        throw new Error(t("noSelectionError"));
                    } else if (defaultScope === "stale") {
                        const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                        scopeTasks = flattenedTasks.filter(task => {
                            return !task.completed && !task.dropped && task.added && task.added < thirtyDaysAgo;
                        });
                        console.log("Headless: analyzing tasks older than 30 days:", scopeTasks.length);
                    } else {
                        scopeTasks = flattenedTasks.filter(task => !task.completed && !task.dropped);
                        console.log("Headless: analyzing all incomplete tasks:", scopeTasks.length);
                    }
                } else {
                    const form = new Form();
                    const scopeOptions = [t("scopeSelected"), t("scopeAll"), t("scopeStale")];
                    const scopeField = new Form.Field.Option(
                        "scope",
                        t("scopeLabel"),
                        scopeOptions,
                        null,
                        scopeOptions[1]
                    );
                    form.addField(scopeField);

                    const formPrompt = await form.show(t("scopeTitle"), t("continueButton"));
                    const scope = formPrompt.values.scope;
                    console.log("User selected scope:", scope);

                    if (scope === scopeOptions[0]) {
                        throw new Error(t("noSelectionError"));
                    } else if (scope === scopeOptions[1]) {
                        scopeTasks = flattenedTasks.filter(task => !task.completed && !task.dropped);
                        console.log("Analyzing all incomplete tasks:", scopeTasks.length);
                    } else {
                        const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                        scopeTasks = flattenedTasks.filter(task => {
                            return !task.completed && !task.dropped && task.added && task.added < thirtyDaysAgo;
                        });
                        console.log("Analyzing tasks older than 30 days:", scopeTasks.length);
                    }
                }
                analyzeItems = scopeTasks.map(task => ({item: task, type: 'task'}));
            }

            if (analyzeItems.length === 0) {
                console.log("No items found matching criteria");
                if (!headless) {
                    new Alert(t("noTasksTitle"), t("noTasksMsg")).show();
                }
                return;
            }

            console.log("Total items to analyze:", analyzeItems.length);

            // Limit to 20 items to avoid timeout issues
            if (analyzeItems.length > 20) {
                console.log("Too many items, limiting to 20");
                if (!headless) {
                    const alert = new Alert(t("tooManyTitle"), t("tooManyMsg", {count: analyzeItems.length}));
                    alert.addOption(t("continueButton"));
                    alert.addOption(t("cancelButton"));
                    const choice = await alert.show();
                    if (choice === 1) {
                        console.log("User cancelled due to item limit");
                        return;
                    }
                } else {
                    console.log("Headless: auto-continuing with first 20 items");
                }
                analyzeItems = analyzeItems.slice(0, 20);
                console.log("Limited to 20 items");
            }

            // Prepare data for AI analysis
            console.log("Preparing data for AI analysis...");
            const taskData = analyzeItems.map((entry, index) => {
                if (entry.type === 'project') {
                    return {
                        index: index,
                        name: entry.item.name,
                        note: entry.item.note ? entry.item.note.substring(0, 200) : "",
                        age_days: 0,
                        has_due_date: !!entry.item.dueDate,
                        has_defer_date: !!entry.item.deferDate,
                        flagged: false,
                        tags: "",
                        type: "project"
                    };
                }
                const task = entry.item;
                const age = task.added ? Math.floor((Date.now() - task.added.getTime()) / (1000 * 60 * 60 * 24)) : 0;
                return {
                    index: index,
                    name: task.name,
                    note: task.note ? task.note.substring(0, 200) : "",
                    age_days: age,
                    has_due_date: !!task.dueDate,
                    has_defer_date: !!task.deferDate,
                    flagged: task.flagged,
                    tags: task.tags.map(t => t.name).join(", ")
                };
            });
            console.log("Task data prepared, sample:", JSON.stringify(taskData[0], null, 2));

            // Call AI API
            const effectiveLang = getEffectiveLanguage();
            const langName = LANG_NAMES[effectiveLang] || "English";
            const langInstruction = effectiveLang !== "en"
                ? `\n\nIMPORTANT: Write all suggestion text in ${langName}. The JSON keys (index, issue, severity, suggestion, action) and issue/severity/action enum values must remain in English.`
                : "";

            const systemPrompt = `You are a productivity expert analyzing OmniFocus tasks and projects. Identify items that are:
1. Vague or non-actionable (e.g., "Think about project" instead of "Draft project proposal outline")
2. Too broad (should be broken into subtasks)
3. Missing critical context
4. Stale (old tasks with no progress)
5. Ambiguous or unclear

Items with type "project" are project containers â€” analyze their names and notes for clarity, specificity, and whether they represent a clear outcome.

For each problematic item, provide:
- Issue type (vague/broad/stale/ambiguous/missing-context)
- Severity (low/medium/high)
- Specific, actionable suggestion for improvement
- Recommended action (clarify/break-down/defer/delete/add-context)

IMPORTANT: Return a JSON object with an "analysis" array. Each item must have: index, issue, severity, suggestion, action.
Example format: {"analysis": [{"index": 0, "issue": "vague", "severity": "high", "suggestion": "...", "action": "clarify"}]}${langInstruction}`;

            const userMessage = `Analyze these tasks:\n${JSON.stringify(taskData, null, 2)}`;

            // Show progress
            if (!headless) {
                const progress = new Alert(t("analyzingTitle"), t("analyzingMsg", {provider: provider.label}));
                progress.show(() => {});
            }

            console.log(`Sending request to ${provider.label}...`);

            const aiResponse = await callAI(providerKey, apiKey, systemPrompt, userMessage);

            // Process results
            const issues = aiResponse.results || aiResponse.issues || aiResponse.analysis || [];
            console.log("Issues found:", issues.length);

            if (issues.length === 0) {
                console.log("No issues found, analysis complete");
                if (!headless) {
                    new Alert(t("completeTitle"), t("noIssuesMsg")).show();
                }
                return;
            }

            // Create or get "AI: Needs Improvement" tag
            const tagName = t("tagName");
            console.log(`Creating/finding '${tagName}' tag...`);
            let improvementTag = tags.byName(tagName);
            if (!improvementTag) {
                improvementTag = new Tag(tagName, tags.ending);
                console.log(`Created new '${tagName}' tag`);
            } else {
                console.log(`Found existing '${tagName}' tag`);
            }

            // Apply findings to tasks and projects
            console.log("Applying findings...");
            let updatedCount = 0;
            let flaggedCount = 0;

            issues.forEach((issue, idx) => {
                console.log(`Processing issue ${idx + 1}/${issues.length}:`, JSON.stringify(issue));
                const entry = analyzeItems[issue.index];
                if (!entry) {
                    console.warn(`Item not found at index ${issue.index}`);
                    return;
                }

                console.log(`Updating ${entry.type}: "${entry.item.name}"`);

                const analysisNote = `\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¤– ${t("noteHeader")}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“… ${t("noteDate")}: ${new Date().toLocaleDateString()}

âš ï¸  ${t("noteIssueType")}: ${issue.issue.toUpperCase()}
ğŸ“Š ${t("noteSeverity")}: ${issue.severity.toUpperCase()}

ğŸ’¡ ${t("noteSuggestion")}:
${issue.suggestion}

ğŸ¯ ${t("noteAction")}: ${issue.action}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

                if (entry.type === 'project') {
                    const project = entry.item;
                    project.note = (project.note || "") + analysisNote;
                    if (project.task) {
                        project.task.addTag(improvementTag);
                        if (issue.severity === "high") {
                            project.task.flagged = true;
                            flaggedCount++;
                            console.log(`Flagged project due to high severity`);
                        }
                    }
                } else {
                    const task = entry.item;
                    task.note = (task.note || "") + analysisNote;
                    task.addTag(improvementTag);
                    console.log(`Added 'AI: Needs Improvement' tag`);
                    if (issue.severity === "high") {
                        task.flagged = true;
                        flaggedCount++;
                        console.log(`Flagged task due to high severity`);
                    }
                }

                updatedCount++;
            });
            console.log(`Updated ${updatedCount} items, flagged ${flaggedCount} high-severity`);

            // Show summary
            const summary = `${t("completeTitle")}!\n\n` +
                `${t("summaryItemsAnalyzed")}: ${analyzeItems.length}\n` +
                `${t("summaryIssuesFound")}: ${issues.length}\n` +
                `${t("summaryItemsUpdated")}: ${updatedCount}\n` +
                `${t("summaryFlagged")}: ${flaggedCount}\n\n` +
                `âœ… ${t("summaryTagLine")}\n` +
                `ğŸ“ ${t("summaryNoteLine")}\n` +
                `ğŸš© ${t("summaryFlagLine")}\n\n` +
                t("summaryFilterTip");

            console.log("=== Analysis Summary ===");
            console.log(summary);
            console.log("=== End Debug Log ===");

            if (!headless) {
                new Alert(t("summaryTitle"), summary).show();
            }

        } catch (error) {
            console.error("=== ERROR ===");
            console.error("Error message:", error.message);
            console.error("Error stack:", error.stack);
            console.error("=== End Debug Log ===");
            if (!headless) {
                new Alert(t("errorTitle"), error.message).show();
            }
        }
    });

    action.validate = function(selection, sender) {
        return true; // Always available
    };

    return action;
})();
