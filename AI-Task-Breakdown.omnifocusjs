/*{
    "type": "action",
    "targets": ["omnifocus"],
    "author": "OmniFocus Automation",
    "identifier": "com.omnifocus.ai-task-breakdown",
    "version": "1.9.0",
    "description": "Uses AI to break down tasks into actionable subtasks and generate tasks for projects",
    "label": "AI Task Breakdown",
    "shortLabel": "AI Breakdown",
    "paletteLabel": "Break Down Task with AI",
    "image": "list.bullet.indent"
}*/
(() => {
    const credentials = new Credentials();

    // === Localization ===
    const LANG_NAMES = {
        en: "English", es: "EspaÃ±ol", fr: "FranÃ§ais", de: "Deutsch",
        it: "Italiano", pt: "PortuguÃªs", ja: "æ—¥æœ¬èªž", zh: "ä¸­æ–‡", nl: "Nederlands"
    };

    const STRINGS = {
        en: {
            providerLabel: "AI Provider",
            providerFormTitle: "Choose your AI provider",
            continueButton: "Continue",
            cancelButton: "Cancel",
            credentialsFound: "Credentials Found",
            credentialsFoundMsg: "Stored API key found. What would you like to do?",
            useStoredKey: "Use Stored Key",
            clearReenter: "Clear & Re-enter Key",
            switchProvider: "Switch AI Provider",
            apiKeyLabel: "API Key",
            apiKeyPrompt: "Enter your {provider} API key (will be stored securely in Keychain)",
            apiKeyRequired: "API key is required",
            noIncompleteTitle: "No Incomplete Tasks",
            noIncompleteMsg: "All selected tasks are already completed.",
            noSelectedTitle: "No Tasks Selected",
            noSelectedMsg: "Please select one or more tasks or projects to break down.",
            tooManyTitle: "Too Many Tasks",
            tooManyMsg: "Selected {count} items. Will break down the first 5 only to avoid timeouts.",
            breakingTitle: "Breaking Down Tasks",
            breakingMsg: "Sending tasks to {provider} for breakdown...\n\nThis may take 15-30 seconds.",
            noBreakdownsTitle: "No Breakdowns",
            noBreakdownsMsg: "AI couldn't generate subtasks for the selected items.",
            completeTitle: "Breakdown Complete",
            summaryTitle: "AI Task Breakdown",
            summaryProcessed: "Items processed",
            summaryCreated: "Subtasks created",
            summarySubtaskLine: "Subtasks added to parent tasks",
            summaryTagLine: 'Tagged with "AI: Suggested"',
            summaryNoteLine: "Parent tasks updated with breakdown note",
            summaryReviewTip: "Review and adjust subtasks as needed!",
            errorTitle: "Error",
            noteHeader: "AI TASK BREAKDOWN",
            noteDate: "Date",
            noteCreated: "Created {count} AI-suggested subtasks below",
            noteTagLine: 'Tagged with "AI: Suggested"',
            tagName: "AI: Suggested"
        },
        es: {
            providerLabel: "Proveedor de IA",
            providerFormTitle: "Elige tu proveedor de IA",
            continueButton: "Continuar",
            cancelButton: "Cancelar",
            credentialsFound: "Credenciales encontradas",
            credentialsFoundMsg: "Se encontrÃ³ una clave API almacenada. Â¿QuÃ© deseas hacer?",
            useStoredKey: "Usar clave guardada",
            clearReenter: "Borrar y volver a ingresar",
            switchProvider: "Cambiar proveedor de IA",
            apiKeyLabel: "Clave API",
            apiKeyPrompt: "Ingresa tu clave API de {provider} (se almacenarÃ¡ de forma segura en el Llavero)",
            apiKeyRequired: "La clave API es obligatoria",
            noIncompleteTitle: "Sin tareas pendientes",
            noIncompleteMsg: "Todas las tareas seleccionadas ya estÃ¡n completadas.",
            noSelectedTitle: "Sin tareas seleccionadas",
            noSelectedMsg: "Selecciona una o mÃ¡s tareas o proyectos para desglosar.",
            tooManyTitle: "Demasiadas tareas",
            tooManyMsg: "Se seleccionaron {count} elementos. Solo se desglosarÃ¡n los primeros 5 para evitar tiempos de espera.",
            breakingTitle: "Desglosando tareas",
            breakingMsg: "Enviando tareas a {provider} para desglose...\n\nEsto puede tardar 15-30 segundos.",
            noBreakdownsTitle: "Sin desglose",
            noBreakdownsMsg: "La IA no pudo generar subtareas para los elementos seleccionados.",
            completeTitle: "Desglose completado",
            summaryTitle: "AI Task Breakdown",
            summaryProcessed: "Elementos procesados",
            summaryCreated: "Subtareas creadas",
            summarySubtaskLine: "Subtareas aÃ±adidas a las tareas padre",
            summaryTagLine: 'Etiquetados con "AI: Suggested"',
            summaryNoteLine: "Tareas padre actualizadas con nota de desglose",
            summaryReviewTip: "Â¡Revisa y ajusta las subtareas segÃºn sea necesario!",
            errorTitle: "Error",
            noteHeader: "DESGLOSE DE TAREAS IA",
            noteDate: "Fecha",
            noteCreated: "Se crearon {count} subtareas sugeridas por IA a continuaciÃ³n",
            noteTagLine: 'Etiquetado con "AI: Suggested"',
            tagName: "AI: Suggested"
        },
        fr: {
            providerLabel: "Fournisseur IA",
            providerFormTitle: "Choisissez votre fournisseur IA",
            continueButton: "Continuer",
            cancelButton: "Annuler",
            credentialsFound: "Identifiants trouvÃ©s",
            credentialsFoundMsg: "ClÃ© API stockÃ©e trouvÃ©e. Que souhaitez-vous faire ?",
            useStoredKey: "Utiliser la clÃ© stockÃ©e",
            clearReenter: "Effacer et ressaisir",
            switchProvider: "Changer de fournisseur IA",
            apiKeyLabel: "ClÃ© API",
            apiKeyPrompt: "Entrez votre clÃ© API {provider} (sera stockÃ©e de maniÃ¨re sÃ©curisÃ©e dans le Trousseau)",
            apiKeyRequired: "La clÃ© API est requise",
            noIncompleteTitle: "Aucune tÃ¢che en cours",
            noIncompleteMsg: "Toutes les tÃ¢ches sÃ©lectionnÃ©es sont dÃ©jÃ  terminÃ©es.",
            noSelectedTitle: "Aucune tÃ¢che sÃ©lectionnÃ©e",
            noSelectedMsg: "Veuillez sÃ©lectionner une ou plusieurs tÃ¢ches ou projets Ã  dÃ©composer.",
            tooManyTitle: "Trop de tÃ¢ches",
            tooManyMsg: "{count} Ã©lÃ©ments sÃ©lectionnÃ©s. Seuls les 5 premiers seront dÃ©composÃ©s pour Ã©viter les dÃ©lais.",
            breakingTitle: "DÃ©composition des tÃ¢ches",
            breakingMsg: "Envoi des tÃ¢ches Ã  {provider} pour dÃ©composition...\n\nCela peut prendre 15 Ã  30 secondes.",
            noBreakdownsTitle: "Aucune dÃ©composition",
            noBreakdownsMsg: "L'IA n'a pas pu gÃ©nÃ©rer de sous-tÃ¢ches pour les Ã©lÃ©ments sÃ©lectionnÃ©s.",
            completeTitle: "DÃ©composition terminÃ©e",
            summaryTitle: "AI Task Breakdown",
            summaryProcessed: "Ã‰lÃ©ments traitÃ©s",
            summaryCreated: "Sous-tÃ¢ches crÃ©Ã©es",
            summarySubtaskLine: "Sous-tÃ¢ches ajoutÃ©es aux tÃ¢ches parentes",
            summaryTagLine: 'Ã‰tiquetÃ©s avec "AI: Suggested"',
            summaryNoteLine: "TÃ¢ches parentes mises Ã  jour avec note de dÃ©composition",
            summaryReviewTip: "Examinez et ajustez les sous-tÃ¢ches si nÃ©cessaire !",
            errorTitle: "Erreur",
            noteHeader: "DÃ‰COMPOSITION DE TÃ‚CHES IA",
            noteDate: "Date",
            noteCreated: "CrÃ©Ã© {count} sous-tÃ¢ches suggÃ©rÃ©es par l'IA ci-dessous",
            noteTagLine: 'Ã‰tiquetÃ© avec "AI: Suggested"',
            tagName: "AI: Suggested"
        },
        de: {
            providerLabel: "KI-Anbieter",
            providerFormTitle: "WÃ¤hlen Sie Ihren KI-Anbieter",
            continueButton: "Weiter",
            cancelButton: "Abbrechen",
            credentialsFound: "Zugangsdaten gefunden",
            credentialsFoundMsg: "Gespeicherter API-SchlÃ¼ssel gefunden. Was mÃ¶chten Sie tun?",
            useStoredKey: "Gespeicherten SchlÃ¼ssel verwenden",
            clearReenter: "LÃ¶schen und neu eingeben",
            switchProvider: "KI-Anbieter wechseln",
            apiKeyLabel: "API-SchlÃ¼ssel",
            apiKeyPrompt: "Geben Sie Ihren {provider} API-SchlÃ¼ssel ein (wird sicher im SchlÃ¼sselbund gespeichert)",
            apiKeyRequired: "API-SchlÃ¼ssel ist erforderlich",
            noIncompleteTitle: "Keine offenen Aufgaben",
            noIncompleteMsg: "Alle ausgewÃ¤hlten Aufgaben sind bereits erledigt.",
            noSelectedTitle: "Keine Aufgaben ausgewÃ¤hlt",
            noSelectedMsg: "Bitte wÃ¤hlen Sie eine oder mehrere Aufgaben oder Projekte zum Aufteilen aus.",
            tooManyTitle: "Zu viele Aufgaben",
            tooManyMsg: "{count} Elemente ausgewÃ¤hlt. Nur die ersten 5 werden aufgeteilt.",
            breakingTitle: "Aufgaben werden aufgeteilt",
            breakingMsg: "Aufgaben werden an {provider} zur Aufteilung gesendet...\n\nDies kann 15-30 Sekunden dauern.",
            noBreakdownsTitle: "Keine Aufteilung",
            noBreakdownsMsg: "KI konnte keine Unteraufgaben fÃ¼r die ausgewÃ¤hlten Elemente generieren.",
            completeTitle: "Aufteilung abgeschlossen",
            summaryTitle: "AI Task Breakdown",
            summaryProcessed: "Verarbeitete Elemente",
            summaryCreated: "Erstellte Unteraufgaben",
            summarySubtaskLine: "Unteraufgaben zu Ã¼bergeordneten Aufgaben hinzugefÃ¼gt",
            summaryTagLine: 'Markiert mit "AI: Suggested"',
            summaryNoteLine: "Ãœbergeordnete Aufgaben mit AufschlÃ¼sselungsnotiz aktualisiert",
            summaryReviewTip: "ÃœberprÃ¼fen und passen Sie die Unteraufgaben bei Bedarf an!",
            errorTitle: "Fehler",
            noteHeader: "KI-AUFGABENAUFSCHLÃœSSELUNG",
            noteDate: "Datum",
            noteCreated: "{count} KI-vorgeschlagene Unteraufgaben unten erstellt",
            noteTagLine: 'Markiert mit "AI: Suggested"',
            tagName: "AI: Suggested"
        },
        it: {
            providerLabel: "Provider IA",
            providerFormTitle: "Scegli il tuo provider IA",
            continueButton: "Continua",
            cancelButton: "Annulla",
            credentialsFound: "Credenziali trovate",
            credentialsFoundMsg: "Chiave API memorizzata trovata. Cosa vuoi fare?",
            useStoredKey: "Usa chiave memorizzata",
            clearReenter: "Cancella e reinserisci",
            switchProvider: "Cambia provider IA",
            apiKeyLabel: "Chiave API",
            apiKeyPrompt: "Inserisci la tua chiave API {provider} (verrÃ  memorizzata in modo sicuro nel Portachiavi)",
            apiKeyRequired: "La chiave API Ã¨ obbligatoria",
            noIncompleteTitle: "Nessuna attivitÃ  in corso",
            noIncompleteMsg: "Tutte le attivitÃ  selezionate sono giÃ  completate.",
            noSelectedTitle: "Nessuna attivitÃ  selezionata",
            noSelectedMsg: "Seleziona una o piÃ¹ attivitÃ  o progetti da scomporre.",
            tooManyTitle: "Troppe attivitÃ ",
            tooManyMsg: "Selezionati {count} elementi. Verranno scomposti solo i primi 5.",
            breakingTitle: "Scomposizione attivitÃ ",
            breakingMsg: "Invio attivitÃ  a {provider} per la scomposizione...\n\nPotrebbe richiedere 15-30 secondi.",
            noBreakdownsTitle: "Nessuna scomposizione",
            noBreakdownsMsg: "L'IA non Ã¨ riuscita a generare sotto-attivitÃ  per gli elementi selezionati.",
            completeTitle: "Scomposizione completata",
            summaryTitle: "AI Task Breakdown",
            summaryProcessed: "Elementi elaborati",
            summaryCreated: "Sotto-attivitÃ  create",
            summarySubtaskLine: "Sotto-attivitÃ  aggiunte alle attivitÃ  padre",
            summaryTagLine: 'Etichettati con "AI: Suggested"',
            summaryNoteLine: "AttivitÃ  padre aggiornate con nota di scomposizione",
            summaryReviewTip: "Rivedi e modifica le sotto-attivitÃ  secondo necessitÃ !",
            errorTitle: "Errore",
            noteHeader: "SCOMPOSIZIONE ATTIVITÃ€ IA",
            noteDate: "Data",
            noteCreated: "Create {count} sotto-attivitÃ  suggerite dall'IA qui sotto",
            noteTagLine: 'Etichettato con "AI: Suggested"',
            tagName: "AI: Suggested"
        },
        pt: {
            providerLabel: "Provedor de IA",
            providerFormTitle: "Escolha seu provedor de IA",
            continueButton: "Continuar",
            cancelButton: "Cancelar",
            credentialsFound: "Credenciais encontradas",
            credentialsFoundMsg: "Chave API armazenada encontrada. O que deseja fazer?",
            useStoredKey: "Usar chave armazenada",
            clearReenter: "Limpar e reinserir",
            switchProvider: "Trocar provedor de IA",
            apiKeyLabel: "Chave API",
            apiKeyPrompt: "Insira sua chave API {provider} (serÃ¡ armazenada com seguranÃ§a nas Chaves)",
            apiKeyRequired: "A chave API Ã© obrigatÃ³ria",
            noIncompleteTitle: "Sem tarefas pendentes",
            noIncompleteMsg: "Todas as tarefas selecionadas jÃ¡ estÃ£o concluÃ­das.",
            noSelectedTitle: "Nenhuma tarefa selecionada",
            noSelectedMsg: "Selecione uma ou mais tarefas ou projetos para decompor.",
            tooManyTitle: "Muitas tarefas",
            tooManyMsg: "Selecionados {count} itens. Apenas os primeiros 5 serÃ£o decompostos.",
            breakingTitle: "Decompondo tarefas",
            breakingMsg: "Enviando tarefas para {provider} para decomposiÃ§Ã£o...\n\nIsso pode levar 15-30 segundos.",
            noBreakdownsTitle: "Sem decomposiÃ§Ã£o",
            noBreakdownsMsg: "A IA nÃ£o conseguiu gerar subtarefas para os itens selecionados.",
            completeTitle: "DecomposiÃ§Ã£o concluÃ­da",
            summaryTitle: "AI Task Breakdown",
            summaryProcessed: "Itens processados",
            summaryCreated: "Subtarefas criadas",
            summarySubtaskLine: "Subtarefas adicionadas Ã s tarefas pai",
            summaryTagLine: 'Etiquetados com "AI: Suggested"',
            summaryNoteLine: "Tarefas pai atualizadas com nota de decomposiÃ§Ã£o",
            summaryReviewTip: "Revise e ajuste as subtarefas conforme necessÃ¡rio!",
            errorTitle: "Erro",
            noteHeader: "DECOMPOSIÃ‡ÃƒO DE TAREFAS IA",
            noteDate: "Data",
            noteCreated: "Criadas {count} subtarefas sugeridas pela IA abaixo",
            noteTagLine: 'Etiquetado com "AI: Suggested"',
            tagName: "AI: Suggested"
        },
        ja: {
            providerLabel: "AIãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼",
            providerFormTitle: "AIãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‚’é¸æŠžã—ã¦ãã ã•ã„",
            continueButton: "ç¶šè¡Œ",
            cancelButton: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
            credentialsFound: "èªè¨¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ",
            credentialsFoundMsg: "ä¿å­˜ã•ã‚ŒãŸAPIã‚­ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ã©ã†ã—ã¾ã™ã‹ï¼Ÿ",
            useStoredKey: "ä¿å­˜ã•ã‚ŒãŸã‚­ãƒ¼ã‚’ä½¿ç”¨",
            clearReenter: "å‰Šé™¤ã—ã¦å†å…¥åŠ›",
            switchProvider: "AIãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‚’åˆ‡æ›¿",
            apiKeyLabel: "APIã‚­ãƒ¼",
            apiKeyPrompt: "{provider}ã®APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆã‚­ãƒ¼ãƒã‚§ãƒ¼ãƒ³ã«å®‰å…¨ã«ä¿å­˜ã•ã‚Œã¾ã™ï¼‰",
            apiKeyRequired: "APIã‚­ãƒ¼ã¯å¿…é ˆã§ã™",
            noIncompleteTitle: "æœªå®Œäº†ã‚¿ã‚¹ã‚¯ãªã—",
            noIncompleteMsg: "é¸æŠžã—ãŸã‚¿ã‚¹ã‚¯ã¯ã™ã¹ã¦å®Œäº†æ¸ˆã¿ã§ã™ã€‚",
            noSelectedTitle: "ã‚¿ã‚¹ã‚¯æœªé¸æŠž",
            noSelectedMsg: "åˆ†è§£ã™ã‚‹ã‚¿ã‚¹ã‚¯ã¾ãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’1ã¤ä»¥ä¸Šé¸æŠžã—ã¦ãã ã•ã„ã€‚",
            tooManyTitle: "ã‚¿ã‚¹ã‚¯ãŒå¤šã™ãŽã¾ã™",
            tooManyMsg: "{count}ä»¶ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠžã€‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’é¿ã‘ã‚‹ãŸã‚ã€æœ€åˆã®5ä»¶ã®ã¿åˆ†è§£ã—ã¾ã™ã€‚",
            breakingTitle: "ã‚¿ã‚¹ã‚¯ã‚’åˆ†è§£ä¸­",
            breakingMsg: "ã‚¿ã‚¹ã‚¯ã‚’{provider}ã«é€ä¿¡ã—ã¦åˆ†è§£ä¸­...\n\n15ã€œ30ç§’ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚",
            noBreakdownsTitle: "åˆ†è§£ãªã—",
            noBreakdownsMsg: "AIã¯é¸æŠžã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã®ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚",
            completeTitle: "åˆ†è§£å®Œäº†",
            summaryTitle: "AI Task Breakdown",
            summaryProcessed: "å‡¦ç†ã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ",
            summaryCreated: "ä½œæˆã•ã‚ŒãŸã‚µãƒ–ã‚¿ã‚¹ã‚¯",
            summarySubtaskLine: "ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’è¦ªã‚¿ã‚¹ã‚¯ã«è¿½åŠ ",
            summaryTagLine: '"AI: Suggested" ã§ã‚¿ã‚°ä»˜ã‘',
            summaryNoteLine: "è¦ªã‚¿ã‚¹ã‚¯ã«åˆ†è§£ãƒŽãƒ¼ãƒˆã‚’è¿½åŠ ",
            summaryReviewTip: "å¿…è¦ã«å¿œã˜ã¦ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’ç¢ºèªãƒ»èª¿æ•´ã—ã¦ãã ã•ã„ï¼",
            errorTitle: "ã‚¨ãƒ©ãƒ¼",
            noteHeader: "AIã‚¿ã‚¹ã‚¯åˆ†è§£",
            noteDate: "æ—¥ä»˜",
            noteCreated: "ä»¥ä¸‹ã«{count}ä»¶ã®AIææ¡ˆã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ",
            noteTagLine: '"AI: Suggested" ã§ã‚¿ã‚°ä»˜ã‘',
            tagName: "AI: Suggested"
        },
        zh: {
            providerLabel: "AI æä¾›å•†",
            providerFormTitle: "é€‰æ‹©æ‚¨çš„ AI æä¾›å•†",
            continueButton: "ç»§ç»­",
            cancelButton: "å–æ¶ˆ",
            credentialsFound: "å·²æ‰¾åˆ°å‡­æ®",
            credentialsFoundMsg: "å·²æ‰¾åˆ°å­˜å‚¨çš„ API å¯†é’¥ã€‚æ‚¨æƒ³æ€Žä¹ˆåšï¼Ÿ",
            useStoredKey: "ä½¿ç”¨å·²å­˜å‚¨çš„å¯†é’¥",
            clearReenter: "æ¸…é™¤å¹¶é‡æ–°è¾“å…¥",
            switchProvider: "åˆ‡æ¢ AI æä¾›å•†",
            apiKeyLabel: "API å¯†é’¥",
            apiKeyPrompt: "è¾“å…¥æ‚¨çš„ {provider} API å¯†é’¥ï¼ˆå°†å®‰å…¨å­˜å‚¨åœ¨é’¥åŒ™ä¸²ä¸­ï¼‰",
            apiKeyRequired: "API å¯†é’¥æ˜¯å¿…å¡«é¡¹",
            noIncompleteTitle: "æ— æœªå®Œæˆä»»åŠ¡",
            noIncompleteMsg: "æ‰€é€‰ä»»åŠ¡å‡å·²å®Œæˆã€‚",
            noSelectedTitle: "æœªé€‰æ‹©ä»»åŠ¡",
            noSelectedMsg: "è¯·é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ªä»»åŠ¡æˆ–é¡¹ç›®è¿›è¡Œåˆ†è§£ã€‚",
            tooManyTitle: "ä»»åŠ¡è¿‡å¤š",
            tooManyMsg: "å·²é€‰æ‹© {count} ä¸ªé¡¹ç›®ã€‚ä¸ºé¿å…è¶…æ—¶ï¼Œä»…åˆ†è§£å‰5ä¸ªã€‚",
            breakingTitle: "æ­£åœ¨åˆ†è§£ä»»åŠ¡",
            breakingMsg: "æ­£åœ¨å°†ä»»åŠ¡å‘é€åˆ° {provider} è¿›è¡Œåˆ†è§£...\n\nè¿™å¯èƒ½éœ€è¦15-30ç§’ã€‚",
            noBreakdownsTitle: "æ— åˆ†è§£ç»“æžœ",
            noBreakdownsMsg: "AI æ— æ³•ä¸ºæ‰€é€‰é¡¹ç›®ç”Ÿæˆå­ä»»åŠ¡ã€‚",
            completeTitle: "åˆ†è§£å®Œæˆ",
            summaryTitle: "AI Task Breakdown",
            summaryProcessed: "å·²å¤„ç†é¡¹ç›®",
            summaryCreated: "å·²åˆ›å»ºå­ä»»åŠ¡",
            summarySubtaskLine: "å­ä»»åŠ¡å·²æ·»åŠ åˆ°çˆ¶ä»»åŠ¡",
            summaryTagLine: 'å·²æ ‡è®° "AI: Suggested"',
            summaryNoteLine: "çˆ¶ä»»åŠ¡å·²æ›´æ–°åˆ†è§£å¤‡æ³¨",
            summaryReviewTip: "è¯·æ ¹æ®éœ€è¦æ£€æŸ¥å’Œè°ƒæ•´å­ä»»åŠ¡ï¼",
            errorTitle: "é”™è¯¯",
            noteHeader: "AI ä»»åŠ¡åˆ†è§£",
            noteDate: "æ—¥æœŸ",
            noteCreated: "ä»¥ä¸‹åˆ›å»ºäº† {count} ä¸ª AI å»ºè®®å­ä»»åŠ¡",
            noteTagLine: 'å·²æ ‡è®° "AI: Suggested"',
            tagName: "AI: Suggested"
        },
        nl: {
            providerLabel: "AI-provider",
            providerFormTitle: "Kies je AI-provider",
            continueButton: "Doorgaan",
            cancelButton: "Annuleren",
            credentialsFound: "Inloggegevens gevonden",
            credentialsFoundMsg: "Opgeslagen API-sleutel gevonden. Wat wil je doen?",
            useStoredKey: "Opgeslagen sleutel gebruiken",
            clearReenter: "Wissen en opnieuw invoeren",
            switchProvider: "Wissel van AI-provider",
            apiKeyLabel: "API-sleutel",
            apiKeyPrompt: "Voer je {provider} API-sleutel in (wordt veilig opgeslagen in de Sleutelhanger)",
            apiKeyRequired: "API-sleutel is vereist",
            noIncompleteTitle: "Geen openstaande taken",
            noIncompleteMsg: "Alle geselecteerde taken zijn al voltooid.",
            noSelectedTitle: "Geen taken geselecteerd",
            noSelectedMsg: "Selecteer een of meer taken of projecten om op te splitsen.",
            tooManyTitle: "Te veel taken",
            tooManyMsg: "{count} items geselecteerd. Alleen de eerste 5 worden opgesplitst om time-outs te voorkomen.",
            breakingTitle: "Taken opsplitsen",
            breakingMsg: "Taken worden naar {provider} gestuurd voor opsplitsing...\n\nDit kan 15-30 seconden duren.",
            noBreakdownsTitle: "Geen opsplitsing",
            noBreakdownsMsg: "AI kon geen subtaken genereren voor de geselecteerde items.",
            completeTitle: "Opsplitsing voltooid",
            summaryTitle: "AI Task Breakdown",
            summaryProcessed: "Verwerkte items",
            summaryCreated: "Aangemaakte subtaken",
            summarySubtaskLine: "Subtaken toegevoegd aan bovenliggende taken",
            summaryTagLine: 'Getagd met "AI: Suggested"',
            summaryNoteLine: "Bovenliggende taken bijgewerkt met opsplitsingsnotitie",
            summaryReviewTip: "Controleer en pas de subtaken aan indien nodig!",
            errorTitle: "Fout",
            noteHeader: "AI TAAKOPSPLITSING",
            noteDate: "Datum",
            noteCreated: "{count} door AI voorgestelde subtaken hieronder aangemaakt",
            noteTagLine: 'Getagd met "AI: Suggested"',
            tagName: "AI: Suggested"
        }
    };

    function getSystemLanguage() {
        try {
            const locale = Intl.DateTimeFormat().resolvedOptions().locale;
            return locale ? locale.split("-")[0].toLowerCase() : "en";
        } catch (e) {
            return "en";
        }
    }

    function getEffectiveLanguage() {
        const prefs = new Preferences("com.omnifocus.headless-settings");
        const override = prefs.readString("language");
        if (override && override !== "auto") {
            return STRINGS[override] ? override : "en";
        }
        const detected = getSystemLanguage();
        return STRINGS[detected] ? detected : "en";
    }

    function t(key, replacements) {
        const lang = getEffectiveLanguage();
        let str = (STRINGS[lang] && STRINGS[lang][key]) || STRINGS.en[key] || key;
        if (replacements) {
            for (const [k, v] of Object.entries(replacements)) {
                str = str.replace(`{${k}}`, v);
            }
        }
        return str;
    }

    const AI_PROVIDERS = {
        chatgpt: {
            label: "ChatGPT (OpenAI)",
            credentialService: "openai",
            buildRequest(apiKey, systemPrompt, userMessage) {
                const request = new URL.FetchRequest();
                request.url = URL.fromString("https://api.openai.com/v1/chat/completions");
                request.method = "POST";
                request.headers = {
                    "Authorization": `Bearer ${apiKey}`,
                    "Content-Type": "application/json"
                };
                request.bodyString = JSON.stringify({
                    model: "gpt-5-2025-08-07",
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: userMessage }
                    ],
                    response_format: { type: "json_object" }
                });
                return request;
            },
            parseResponse(responseBody) {
                const data = JSON.parse(responseBody);
                return JSON.parse(data.choices[0].message.content);
            }
        },
        claude: {
            label: "Claude (Anthropic)",
            credentialService: "anthropic",
            buildRequest(apiKey, systemPrompt, userMessage) {
                const request = new URL.FetchRequest();
                request.url = URL.fromString("https://api.anthropic.com/v1/messages");
                request.method = "POST";
                request.headers = {
                    "x-api-key": apiKey,
                    "anthropic-version": "2023-06-01",
                    "Content-Type": "application/json"
                };
                request.bodyString = JSON.stringify({
                    model: "claude-sonnet-4-20250514",
                    max_tokens: 4096,
                    system: systemPrompt + "\n\nIMPORTANT: Respond with only a valid JSON object, no other text.",
                    messages: [
                        { role: "user", content: userMessage }
                    ]
                });
                return request;
            },
            parseResponse(responseBody) {
                const data = JSON.parse(responseBody);
                const text = data.content[0].text;
                try {
                    return JSON.parse(text);
                } catch (e) {
                    const match = text.match(/\{[\s\S]*\}/);
                    if (match) {
                        return JSON.parse(match[0]);
                    }
                    throw new Error("Failed to parse AI response as JSON");
                }
            }
        }
    };

    async function callAI(providerKey, apiKey, systemPrompt, userMessage) {
        const provider = AI_PROVIDERS[providerKey];
        console.log(`Calling ${provider.label} API...`);

        const request = provider.buildRequest(apiKey, systemPrompt, userMessage);

        console.log("=== AI API Request ===");
        console.log("URL:", request.url.string);
        console.log("Method:", request.method);
        console.log("API Key (first 20 chars):", apiKey.substring(0, 20) + "...");

        let response;
        try {
            response = await request.fetch();
        } catch (fetchError) {
            console.error("Fetch error:", fetchError);
            throw new Error(`Network request failed: ${fetchError.message || 'Request timed out'}. Check your internet connection.`);
        }

        console.log("=== AI API Response ===");
        console.log("Status Code:", response.statusCode);
        console.log("Response Body:", response.bodyString);

        if (response.statusCode !== 200) {
            console.error("API Error - Status:", response.statusCode);
            console.error("API Error - Body:", response.bodyString);
            throw new Error(`API Error: ${response.statusCode} - ${response.bodyString}`);
        }

        const parsed = provider.parseResponse(response.bodyString);
        console.log("Parsed AI response:", JSON.stringify(parsed, null, 2));
        return parsed;
    }

    const action = new PlugIn.Action(async function(selection, sender) {
        try {
            console.log("=== AI Task Breakdown Debug Log ===");
            console.log("Starting plugin execution...");

            // Headless mode: skip all dialogs, use stored credentials and defaults
            const prefs = new Preferences("com.omnifocus.ai-task-breakdown");
            const headless = prefs.readBoolean("headlessMode");
            console.log("Headless mode:", headless);

            // --- Provider selection ---
            let providerKey = prefs.readString("aiProvider");
            let provider = providerKey ? AI_PROVIDERS[providerKey] : null;

            if (!provider) {
                if (headless) {
                    providerKey = "chatgpt";
                    provider = AI_PROVIDERS[providerKey];
                    console.log("Headless: defaulting to ChatGPT");
                } else {
                    const providerForm = new Form();
                    providerForm.addField(new Form.Field.Option(
                        "aiProvider",
                        t("providerLabel"),
                        ["chatgpt", "claude"],
                        ["ChatGPT (OpenAI)", "Claude (Anthropic)"],
                        "chatgpt"
                    ));
                    const providerResult = await providerForm.show(t("providerFormTitle"), t("continueButton"));
                    providerKey = providerResult.values.aiProvider;
                    provider = AI_PROVIDERS[providerKey];
                    prefs.write("aiProvider", providerKey);
                    console.log("User selected provider:", providerKey);
                }
            }

            // --- Credential flow ---
            let apiKey = null;
            const storedCreds = credentials.read(provider.credentialService);
            console.log("Credentials check:", storedCreds ? "Found stored credentials" : "No stored credentials");

            if (!storedCreds || !storedCreds.password) {
                console.log("No credentials found, prompting user (required for first run)...");
                const form = new Form();
                form.addField(new Form.Field.Password("apiKey", `${provider.label} ${t("apiKeyLabel")}`, null));
                const formPrompt = await form.show(t("apiKeyPrompt", {provider: provider.label}), t("continueButton"));
                apiKey = formPrompt.values.apiKey;
                if (!apiKey) {
                    throw new Error(t("apiKeyRequired"));
                }
                console.log("Storing new API key in Keychain...");
                credentials.write(provider.credentialService, "api-key", apiKey);
                console.log("API key stored successfully");
            } else if (headless) {
                apiKey = storedCreds.password;
                console.log("Headless: using stored API key");
            } else {
                const alert = new Alert(`${provider.label} â€” ${t("credentialsFound")}`, t("credentialsFoundMsg"));
                alert.addOption(t("useStoredKey"));
                alert.addOption(t("clearReenter"));
                alert.addOption(t("switchProvider"));
                alert.addOption(t("cancelButton"));

                const choice = await alert.show();

                if (choice === 0) {
                    apiKey = storedCreds.password;
                    console.log("Using stored API key");
                } else if (choice === 1) {
                    console.log("Clearing stored credentials...");
                    credentials.remove(provider.credentialService);
                    const form = new Form();
                    form.addField(new Form.Field.Password("apiKey", `${provider.label} ${t("apiKeyLabel")}`, null));
                    const formPrompt = await form.show(t("apiKeyPrompt", {provider: provider.label}), t("continueButton"));
                    apiKey = formPrompt.values.apiKey;
                    if (!apiKey) {
                        throw new Error(t("apiKeyRequired"));
                    }
                    console.log("Storing new API key in Keychain...");
                    credentials.write(provider.credentialService, "api-key", apiKey);
                    console.log("API key stored successfully");
                } else if (choice === 2) {
                    const otherKey = providerKey === "chatgpt" ? "claude" : "chatgpt";
                    providerKey = otherKey;
                    provider = AI_PROVIDERS[providerKey];
                    prefs.write("aiProvider", providerKey);
                    console.log("Switched to provider:", providerKey);

                    const switchedCreds = credentials.read(provider.credentialService);
                    if (switchedCreds && switchedCreds.password) {
                        apiKey = switchedCreds.password;
                        console.log("Using stored key for", provider.label);
                    } else {
                        const form = new Form();
                        form.addField(new Form.Field.Password("apiKey", `${provider.label} ${t("apiKeyLabel")}`, null));
                        const formPrompt = await form.show(t("apiKeyPrompt", {provider: provider.label}), t("continueButton"));
                        apiKey = formPrompt.values.apiKey;
                        if (!apiKey) {
                            throw new Error(t("apiKeyRequired"));
                        }
                        credentials.write(provider.credentialService, "api-key", apiKey);
                        console.log("Stored new key for", provider.label);
                    }
                } else {
                    console.log("User cancelled");
                    return;
                }
            }

            // Get selected tasks and projects to break down
            const breakdownItems = []; // [{item, type: 'task'|'project'}, ...]
            for (const task of selection.tasks) {
                if (!task.completed) {
                    breakdownItems.push({item: task, type: 'task'});
                }
            }
            for (const project of selection.projects) {
                breakdownItems.push({item: project, type: 'project'});
            }
            console.log("Items to break down:", breakdownItems.length, "(tasks:", selection.tasks.filter(t => !t.completed).length, "projects:", selection.projects.length + ")");

            if (breakdownItems.length === 0) {
                if (selection.tasks.length > 0) {
                    console.log("No incomplete tasks found");
                    if (!headless) {
                        new Alert(t("noIncompleteTitle"), t("noIncompleteMsg")).show();
                    }
                } else {
                    console.log("No tasks or projects selected");
                    if (!headless) {
                        new Alert(t("noSelectedTitle"), t("noSelectedMsg")).show();
                    }
                }
                return;
            }

            // Limit to 5 items to avoid timeouts
            if (breakdownItems.length > 5) {
                console.log("Too many items, limiting to 5");
                if (!headless) {
                    const alert = new Alert(t("tooManyTitle"), t("tooManyMsg", {count: breakdownItems.length}));
                    alert.addOption(t("continueButton"));
                    alert.addOption(t("cancelButton"));
                    const choice = await alert.show();
                    if (choice === 1) {
                        console.log("User cancelled due to item limit");
                        return;
                    }
                } else {
                    console.log("Headless: auto-continuing with first 5 items");
                }
                breakdownItems.splice(5);
                console.log("Limited to 5 items");
            }

            // Prepare task data for AI
            console.log("Preparing data for AI breakdown...");
            const taskData = breakdownItems.map((entry, index) => {
                if (entry.type === 'project') {
                    return {
                        index: index,
                        name: entry.item.name,
                        note: entry.item.note ? entry.item.note.substring(0, 500) : "",
                        tags: "",
                        type: "project"
                    };
                }
                const task = entry.item;
                return {
                    index: index,
                    name: task.name,
                    note: task.note ? task.note.substring(0, 500) : "",
                    tags: task.tags.map(t => t.name).join(", "),
                    project: task.containingProject ? task.containingProject.name : "Inbox"
                };
            });
            console.log("Task data prepared, sample:", JSON.stringify(taskData[0], null, 2));

            // Call AI API
            const effectiveLang = getEffectiveLanguage();
            const langName = LANG_NAMES[effectiveLang] || "English";
            const langInstruction = effectiveLang !== "en"
                ? `\n\nIMPORTANT: Write all subtask names in ${langName}. The JSON keys (index, subtasks) must remain in English.`
                : "";

            const systemPrompt = `You are a productivity expert helping break down tasks and projects into actionable items.

For each item, create the MINIMUM number of essential sub-items needed (typically 2-5, maximum 10 for very complex items).
- Items with type "project" are project containers: generate top-level tasks that belong in that project.
- All other items are tasks: generate subtasks that break down the task.

Guidelines:
- Be SUCCINCT - only include truly necessary steps
- Use brief, bullet-point style (not full sentences)
- Skip obvious/trivial steps
- Combine related steps when possible
- No punctuation needed (these are todo items)
- Only break down if item genuinely needs it
- Simple items may only need 2-3 subtasks
- Complex items can have up to 10 subtasks

Format:
- Brief action phrases (e.g., "Schedule appointment", "Check account balance")
- No periods, no "I will", no "You should"
- Start with verb when possible

IMPORTANT: Return a JSON object with a "breakdowns" array. Each item must have: index, subtasks (array of strings).
Example format: {"breakdowns": [{"index": 0, "subtasks": ["Research options", "Book appointment", "Add to calendar"]}]}${langInstruction}`;

            const userMessage = `Break down these items into actionable subtasks:\n${JSON.stringify(taskData, null, 2)}`;

            // Show progress
            if (!headless) {
                const progress = new Alert(t("breakingTitle"), t("breakingMsg", {provider: provider.label}));
                progress.show(() => {});
            }

            console.log(`Sending request to ${provider.label}...`);

            const aiResponse = await callAI(providerKey, apiKey, systemPrompt, userMessage);

            // Process results
            const breakdowns = aiResponse.breakdowns || aiResponse.results || [];
            console.log("Breakdowns found:", breakdowns.length);

            if (breakdowns.length === 0) {
                console.log("No breakdowns found");
                if (!headless) {
                    new Alert(t("noBreakdownsTitle"), t("noBreakdownsMsg")).show();
                }
                return;
            }

            // Create or get "AI: Suggested" tag
            const tagName = t("tagName");
            console.log(`Creating/finding '${tagName}' tag...`);
            let suggestedTag = tags.byName(tagName);
            if (!suggestedTag) {
                suggestedTag = new Tag(tagName, tags.ending);
                console.log(`Created new '${tagName}' tag`);
            } else {
                console.log(`Found existing '${tagName}' tag`);
            }

            // Apply breakdowns to tasks and projects
            console.log("Creating subtasks...");
            let totalSubtasks = 0;

            breakdowns.forEach((breakdown, idx) => {
                console.log(`Processing breakdown ${idx + 1}/${breakdowns.length}:`, JSON.stringify(breakdown));
                const entry = breakdownItems[breakdown.index];
                if (!entry) {
                    console.warn(`Item not found at index ${breakdown.index}`);
                    return;
                }

                const subtasks = breakdown.subtasks || [];
                const breakdownNote = `\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ¤– ${t("noteHeader")}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“… ${t("noteDate")}: ${new Date().toLocaleDateString()}

âœ… ${t("noteCreated", {count: subtasks.length})}
ðŸ·ï¸  ${t("noteTagLine")}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

                if (entry.type === 'project') {
                    const project = entry.item;
                    console.log(`Creating tasks for project: "${project.name}"`);
                    console.log(`Creating ${subtasks.length} tasks`);

                    project.note = (project.note || "") + breakdownNote;

                    subtasks.forEach((taskName, subIdx) => {
                        console.log(`Creating task ${subIdx + 1}/${subtasks.length}: "${taskName}"`);
                        const newTask = new Task(taskName, project.ending);
                        newTask.addTag(suggestedTag);
                        totalSubtasks++;
                    });

                    console.log(`Created ${subtasks.length} tasks for project "${project.name}"`);
                } else {
                    const task = entry.item;
                    console.log(`Creating subtasks for: "${task.name}"`);
                    console.log(`Creating ${subtasks.length} subtasks`);

                    task.note = (task.note || "") + breakdownNote;

                    subtasks.forEach((subtaskName, subIdx) => {
                        console.log(`Creating subtask ${subIdx + 1}/${subtasks.length}: "${subtaskName}"`);
                        const subtask = new Task(subtaskName, task.ending);
                        subtask.addTag(suggestedTag);
                        totalSubtasks++;
                    });

                    console.log(`Created ${subtasks.length} subtasks for "${task.name}"`);
                }
            });

            console.log(`Total subtasks created: ${totalSubtasks}`);

            // Show summary
            const summary = `${t("completeTitle")}!\n\n` +
                `${t("summaryProcessed")}: ${breakdowns.length}\n` +
                `${t("summaryCreated")}: ${totalSubtasks}\n\n` +
                `âœ… ${t("summarySubtaskLine")}\n` +
                `ðŸ·ï¸  ${t("summaryTagLine")}\n` +
                `ðŸ“ ${t("summaryNoteLine")}\n\n` +
                t("summaryReviewTip");

            console.log("=== Breakdown Summary ===");
            console.log(summary);
            console.log("=== End Debug Log ===");

            if (!headless) {
                new Alert(t("summaryTitle"), summary).show();
            }

        } catch (error) {
            console.error("=== ERROR ===");
            console.error("Error message:", error.message);
            console.error("Error stack:", error.stack);
            console.error("=== End Debug Log ===");
            if (!headless) {
                new Alert(t("errorTitle"), error.message).show();
            }
        }
    });

    action.validate = function(selection, sender) {
        // Enable if tasks or projects are selected
        return selection.tasks.length > 0 || selection.projects.length > 0;
    };

    return action;
})();
